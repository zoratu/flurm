%%%-------------------------------------------------------------------
%%% @doc Comprehensive EUnit Tests for FLURM Protocol Codec
%%%
%%% Tests for:
%%% - All message encoding/decoding functions
%%% - Error handling paths
%%% - Edge cases
%%% - Helper functions (time parsing, resource extraction)
%%% - Roundtrip tests (encode then decode)
%%% - Dispatch logic in the main codec module
%%% @end
%%%-------------------------------------------------------------------
-module(flurm_protocol_codec_tests).

-include_lib("eunit/include/eunit.hrl").
-include("flurm_protocol.hrl").

-define(CODEC_SRC, "apps/flurm_protocol/src/flurm_protocol_codec.erl").
-define(PROTOCOL_HRL, "apps/flurm_protocol/include/flurm_protocol.hrl").

%%%===================================================================
%%% Test Setup/Cleanup
%%%===================================================================

%% Module-level setup that runs once for all tests
codec_test_() ->
    {setup,
     fun module_setup/0,
     fun module_cleanup/1,
     fun(_) ->
         [
          encode_decode_tests(),
          node_info_tests(),
          job_info_response_tests(),
          kill_job_tests(),
          batch_job_request_tests(),
          job_step_tests(),
          info_query_tests(),
          reconfigure_tests(),
          resource_allocation_tests(),
          message_type_helper_tests(),
          decode_error_tests(),
          protocol_resource_tests(),
          decode_body_tests(),
          encode_body_tests(),
          with_extra_tests(),
          response_tests(),
          edge_case_tests(),
          generated_mapping_tests(),
          %% New comprehensive tests
          time_parsing_tests(),
          resource_extraction_tests(),
          string_helper_tests(),
          auth_section_tests(),
          header_integration_tests(),
          full_roundtrip_tests(),
          cancel_job_tests(),
          suspend_signal_tests(),
          script_parsing_tests(),
          memory_parsing_tests(),
          array_spec_tests(),
          node_registration_tests(),
          partition_info_tests(),
          decode_body_comprehensive_tests(),
          encode_body_comprehensive_tests(),
          response_encoding_tests(),
          job_info_request_tests(),
          batch_job_decode_tests(),
          error_path_tests(),
          binary_scanning_tests(),
          dispatch_logic_tests(),
          message_type_boundary_tests(),
          large_value_tests(),
          federation_message_tests(),
          srun_callback_tests(),
          encode_response_variants_tests(),
          %% NEW: Additional comprehensive tests
          comprehensive_time_parsing_tests(),
          comprehensive_resource_extraction_tests(),
          comprehensive_memory_tests(),
          comprehensive_job_name_tests(),
          comprehensive_partition_tests(),
          comprehensive_array_spec_tests(),
          comprehensive_output_path_tests(),
          comprehensive_kill_cancel_signal_tests(),
          comprehensive_prolog_epilog_tests(),
          comprehensive_roundtrip_tests(),
          comprehensive_error_path_tests(),
          extended_auth_section_tests(),
          extended_message_type_tests(),
          info_response_encoding_tests(),
          srun_message_tests(),
          resource_allocation_response_tests(),
          extract_full_job_desc_tests(),
          response_encoding_variants_tests(),
          reconfigure_response_tests(),
          %% NEW: Even more comprehensive tests
          job_step_request_response_tests(),
          launch_tasks_tests(),
          info_query_request_tests(),
          info_query_response_tests(),
          job_control_tests(),
          complete_prolog_epilog_tests(),
          header_encoding_decoding_tests(),
          binary_encoding_helpers_tests(),
          protocol_version_tests(),
          message_structure_tests(),
          %% NEW: Even more comprehensive tests
          additional_sbatch_directive_tests(),
          additional_encode_body_tests(),
          additional_roundtrip_tests(),
          additional_error_handling_tests(),
          additional_message_type_tests(),
          %% Phase 2: Additional comprehensive tests
          federation_encode_decode_tests(),
          federation_inter_cluster_tests(),
          info_response_encoding_comprehensive_tests(),
          helper_function_comprehensive_tests(),
          job_step_info_comprehensive_tests(),
          launch_tasks_comprehensive_tests(),
          reconfigure_comprehensive_tests(),
          shutdown_tests(),
          binary_packing_tests(),
          node_partition_extended_tests(),
          job_info_extended_tests(),
          resource_allocation_extended_tests(),
          srun_callback_extended_tests(),
          decode_request_extended_tests(),
          string_unpacking_tests(),
          message_type_classification_extended_tests(),
          decode_body_extended_tests(),
          encode_body_extended_tests(),
          batch_job_response_encoding_tests(),
          extended_roundtrip_tests(),
          settings_map_tests(),
          fed_clusters_tests()
         ]
     end}.

module_setup() ->
    %% Mock lager since it uses parse transform and may not be available
    %% Use non_strict since lager functions don't actually exist (they're transformed)
    meck:new(lager, [non_strict, no_link]),
    meck:expect(lager, debug, fun(_, _) -> ok end),
    meck:expect(lager, info, fun(_, _) -> ok end),
    meck:expect(lager, warning, fun(_, _) -> ok end),
    meck:expect(lager, error, fun(_, _) -> ok end),
    meck:expect(lager, md, fun(_) -> ok end),
    ok.

module_cleanup(_) ->
    meck:unload(lager),
    ok.

%%%===================================================================
%%% Basic encode/decode Tests
%%%===================================================================

encode_decode_tests() ->
    [
        {"encode REQUEST_PING", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_PING, #ping_request{}),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) >= 14)  % 4 byte length + 10 byte header
        end},

        {"decode REQUEST_PING roundtrip", fun() ->
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_PING, #ping_request{}),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(?REQUEST_PING, Msg#slurm_msg.header#slurm_header.msg_type),
            ?assertMatch(#ping_request{}, Msg#slurm_msg.body)
        end},

        {"encode RESPONSE_SLURM_RC", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = 0}),
            ?assert(is_binary(Binary))
        end},

        {"decode RESPONSE_SLURM_RC roundtrip", fun() ->
            {ok, Encoded} = flurm_protocol_codec:encode(?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = -1}),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(?RESPONSE_SLURM_RC, Msg#slurm_msg.header#slurm_header.msg_type),
            ?assertEqual(-1, (Msg#slurm_msg.body)#slurm_rc_response.return_code)
        end},

        {"encode REQUEST_JOB_INFO", fun() ->
            Req = #job_info_request{show_flags = 1, job_id = 123, user_id = 1000},
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_JOB_INFO, Req),
            ?assert(is_binary(Binary))
        end},

        {"decode REQUEST_JOB_INFO roundtrip", fun() ->
            Req = #job_info_request{show_flags = 2, job_id = 456, user_id = 500},
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_JOB_INFO, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(?REQUEST_JOB_INFO, Msg#slurm_msg.header#slurm_header.msg_type),
            Body = Msg#slurm_msg.body,
            ?assertEqual(2, Body#job_info_request.show_flags),
            ?assertEqual(456, Body#job_info_request.job_id),
            ?assertEqual(500, Body#job_info_request.user_id)
        end},

        {"encode REQUEST_NODE_REGISTRATION_STATUS", fun() ->
            Req = #node_registration_request{status_only = true},
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_NODE_REGISTRATION_STATUS, Req),
            ?assert(is_binary(Binary))
        end},

        {"decode REQUEST_NODE_REGISTRATION_STATUS roundtrip", fun() ->
            lists:foreach(fun(StatusOnly) ->
                Req = #node_registration_request{status_only = StatusOnly},
                {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_NODE_REGISTRATION_STATUS, Req),
                {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
                ?assertEqual(StatusOnly, (Msg#slurm_msg.body)#node_registration_request.status_only)
            end, [true, false])
        end},

        {"encode REQUEST_CANCEL_JOB", fun() ->
            Req = #cancel_job_request{job_id = 999, step_id = 0, signal = 15, flags = 0},
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_CANCEL_JOB, Req),
            ?assert(is_binary(Binary))
        end},

        {"decode REQUEST_CANCEL_JOB roundtrip", fun() ->
            Req = #cancel_job_request{job_id = 12345, job_id_str = <<"12345">>, step_id = 1, signal = 9, flags = 0},
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_CANCEL_JOB, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            Body = Msg#slurm_msg.body,
            ?assertEqual(12345, Body#cancel_job_request.job_id),
            ?assertEqual(9, Body#cancel_job_request.signal)
        end},

        {"encode RESPONSE_SUBMIT_BATCH_JOB", fun() ->
            Resp = #batch_job_response{job_id = 10000, step_id = 0, error_code = 0},
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_SUBMIT_BATCH_JOB, Resp),
            ?assert(is_binary(Binary))
        end},

        {"decode RESPONSE_SUBMIT_BATCH_JOB roundtrip", fun() ->
            Resp = #batch_job_response{job_id = 88888, step_id = 0, error_code = 0, job_submit_user_msg = <<"OK">>},
            {ok, Encoded} = flurm_protocol_codec:encode(?RESPONSE_SUBMIT_BATCH_JOB, Resp),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            Body = Msg#slurm_msg.body,
            ?assertEqual(88888, Body#batch_job_response.job_id),
            ?assertEqual(0, Body#batch_job_response.error_code),
            ?assertEqual(<<"OK">>, Body#batch_job_response.job_submit_user_msg)
        end}
    ].

%%%===================================================================
%%% Node and Partition Info Tests
%%%===================================================================

node_info_tests() ->
    [
        {"encode REQUEST_NODE_INFO", fun() ->
            Req = #node_info_request{show_flags = 0, node_name = <<"node01">>},
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_NODE_INFO, Req),
            ?assert(is_binary(Binary))
        end},

        {"encode RESPONSE_NODE_INFO", fun() ->
            Node = #node_info{
                name = <<"node01">>,
                node_hostname = <<"node01.local">>,
                node_addr = <<"192.168.1.1">>,
                port = 6818,
                node_state = 0,
                cpus = 64,
                boards = 1,
                sockets = 2,
                cores = 16,
                threads = 2,
                real_memory = 131072,
                tmp_disk = 102400,
                weight = 1,
                arch = <<"x86_64">>,
                features = <<"gpu,nvme">>,
                features_act = <<"gpu,nvme">>,
                os = <<"Linux">>,
                version = <<"22.05">>
            },
            Resp = #node_info_response{
                last_update = erlang:system_time(second),
                node_count = 1,
                nodes = [Node]
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_NODE_INFO, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode REQUEST_PARTITION_INFO", fun() ->
            Req = #partition_info_request{show_flags = 0, partition_name = <<"batch">>},
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_PARTITION_INFO, Req),
            ?assert(is_binary(Binary))
        end},

        {"encode RESPONSE_PARTITION_INFO", fun() ->
            Part = #partition_info{
                name = <<"batch">>,
                max_time = 1440,
                default_time = 60,
                max_nodes = 100,
                min_nodes = 1,
                total_nodes = 50,
                total_cpus = 3200,
                priority_job_factor = 1,
                priority_tier = 1,
                state_up = 1,
                nodes = <<"node[01-50]">>
            },
            Resp = #partition_info_response{
                last_update = erlang:system_time(second),
                partition_count = 1,
                partitions = [Part]
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_PARTITION_INFO, Resp),
            ?assert(is_binary(Binary))
        end}
    ].

%%%===================================================================
%%% Job Info Response Tests
%%%===================================================================

job_info_response_tests() ->
    [
        {"encode RESPONSE_JOB_INFO with empty jobs", fun() ->
            Resp = #job_info_response{
                last_update = erlang:system_time(second),
                job_count = 0,
                jobs = []
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_JOB_INFO, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode RESPONSE_JOB_INFO with one job", fun() ->
            Job = #job_info{
                job_id = 1234,
                user_id = 1000,
                group_id = 1000,
                name = <<"test_job">>,
                partition = <<"batch">>,
                account = <<"users">>,
                job_state = 1,
                num_nodes = 1,
                num_cpus = 4,
                num_tasks = 4,
                time_limit = 60,
                start_time = erlang:system_time(second),
                submit_time = erlang:system_time(second) - 3600
            },
            Resp = #job_info_response{
                last_update = erlang:system_time(second),
                job_count = 1,
                jobs = [Job]
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_JOB_INFO, Resp),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) > 100)
        end}
    ].

%%%===================================================================
%%% Kill Job Request Tests
%%%===================================================================

kill_job_tests() ->
    [
        {"encode REQUEST_KILL_JOB", fun() ->
            Req = #kill_job_request{
                job_id = 5678,
                job_id_str = <<"5678">>,
                step_id = -1,
                signal = 9,
                flags = 0
            },
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_KILL_JOB, Req),
            ?assert(is_binary(Binary))
        end}
    ].

%%%===================================================================
%%% Batch Job Request Tests
%%%===================================================================

batch_job_request_tests() ->
    [
        {"encode REQUEST_SUBMIT_BATCH_JOB", fun() ->
            Req = #batch_job_request{
                name = <<"test_batch">>,
                script = <<"#!/bin/bash\necho hello">>,
                partition = <<"batch">>,
                min_nodes = 1,
                max_nodes = 1,
                min_cpus = 4,
                num_tasks = 4,
                cpus_per_task = 1,
                time_limit = 60,
                priority = 0,
                user_id = 1000,
                group_id = 1000,
                work_dir = <<"/home/user">>
            },
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_SUBMIT_BATCH_JOB, Req),
            ?assert(is_binary(Binary))
        end},

        {"encode job_submit_req legacy format", fun() ->
            Req = #job_submit_req{
                name = <<"legacy_job">>,
                script = <<"#!/bin/bash\necho test">>,
                partition = <<"default">>,
                num_nodes = 2,
                num_cpus = 8,
                memory_mb = 4096,
                time_limit = 120,
                working_dir = <<"/tmp">>,
                env = #{path => <<"/usr/bin">>}
            },
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_SUBMIT_BATCH_JOB, Req),
            ?assert(is_binary(Binary))
        end}
    ].

%%%===================================================================
%%% Job Step Tests
%%%===================================================================

job_step_tests() ->
    [
        {"encode RESPONSE_JOB_STEP_CREATE", fun() ->
            Resp = #job_step_create_response{
                job_step_id = 0,
                error_code = 0,
                error_msg = <<>>
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_JOB_STEP_CREATE, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode RESPONSE_JOB_STEP_INFO", fun() ->
            Step = #job_step_info{
                job_id = 1234,
                step_id = 0,
                step_name = <<"batch">>,
                partition = <<"batch">>,
                user_id = 1000,
                state = 1,
                num_tasks = 4,
                num_cpus = 4,
                time_limit = 60,
                start_time = erlang:system_time(second),
                run_time = 30,
                nodes = <<"node01">>,
                node_cnt = 1,
                exit_code = 0
            },
            Resp = #job_step_info_response{
                last_update = erlang:system_time(second),
                step_count = 1,
                steps = [Step]
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_JOB_STEP_INFO, Resp),
            ?assert(is_binary(Binary))
        end}
    ].

%%%===================================================================
%%% Info/Query Messages Tests
%%%===================================================================

info_query_tests() ->
    [
        {"encode RESPONSE_RESERVATION_INFO", fun() ->
            Resv = #reservation_info{
                name = <<"maint">>,
                accounts = <<"admin">>,
                node_cnt = 10,
                node_list = <<"node[01-10]">>,
                start_time = erlang:system_time(second),
                end_time = erlang:system_time(second) + 3600
            },
            Resp = #reservation_info_response{
                last_update = erlang:system_time(second),
                reservation_count = 1,
                reservations = [Resv]
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_RESERVATION_INFO, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode RESPONSE_LICENSE_INFO", fun() ->
            Lic = #license_info{
                name = <<"matlab">>,
                total = 100,
                in_use = 25,
                available = 75,
                reserved = 0,
                remote = 0
            },
            Resp = #license_info_response{
                last_update = erlang:system_time(second),
                license_count = 1,
                licenses = [Lic]
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_LICENSE_INFO, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode RESPONSE_TOPO_INFO", fun() ->
            Topo = #topo_info{
                level = 0,
                link_speed = 100000,
                name = <<"sw0">>,
                nodes = <<"node[01-10]">>,
                switches = <<>>
            },
            Resp = #topo_info_response{
                topo_count = 1,
                topos = [Topo]
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_TOPO_INFO, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode RESPONSE_FRONT_END_INFO", fun() ->
            FE = #front_end_info{
                name = <<"login01">>,
                node_state = 0,
                boot_time = erlang:system_time(second) - 86400,
                slurmd_start_time = erlang:system_time(second) - 86400,
                version = <<"22.05">>
            },
            Resp = #front_end_info_response{
                last_update = erlang:system_time(second),
                front_end_count = 1,
                front_ends = [FE]
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_FRONT_END_INFO, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode RESPONSE_BURST_BUFFER_INFO", fun() ->
            Pool = #burst_buffer_pool{
                granularity = 1024,
                name = <<"default">>,
                total_space = 1048576,
                unfree_space = 0,
                used_space = 0
            },
            BB = #burst_buffer_info{
                name = <<"cray_aries">>,
                pool_cnt = 1,
                pools = [Pool],
                total_space = 1048576,
                granularity = 1024
            },
            Resp = #burst_buffer_info_response{
                last_update = erlang:system_time(second),
                burst_buffer_count = 1,
                burst_buffers = [BB]
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_BURST_BUFFER_INFO, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode RESPONSE_BUILD_INFO", fun() ->
            Resp = #build_info_response{
                cluster_name = <<"test_cluster">>,
                control_machine = <<"controller">>,
                slurmctld_host = <<"controller">>,
                slurmctld_port = 6817,
                slurmd_port = 6818,
                version = <<"22.05.0">>,
                auth_type = <<"auth/munge">>,
                select_type = <<"select/cons_tres">>,
                scheduler_type = <<"sched/backfill">>,
                priority_type = <<"priority/multifactor">>,
                accounting_storage_type = <<"accounting_storage/slurmdbd">>,
                job_comp_type = <<"jobcomp/none">>
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_BUILD_INFO, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode RESPONSE_CONFIG_INFO", fun() ->
            Resp = #config_info_response{
                last_update = erlang:system_time(second),
                config = #{
                    cluster_name => <<"test">>,
                    max_job_count => 10000,
                    slurmctld_port => 6817
                }
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_CONFIG_INFO, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode RESPONSE_STATS_INFO", fun() ->
            Resp = #stats_info_response{
                parts_packed = 0,
                req_time = erlang:system_time(second),
                req_time_start = erlang:system_time(second) - 3600,
                server_thread_count = 10,
                agent_queue_size = 0,
                jobs_submitted = 1000,
                jobs_started = 950,
                jobs_completed = 900,
                jobs_pending = 50,
                jobs_running = 50
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_STATS_INFO, Resp),
            ?assert(is_binary(Binary))
        end}
    ].

%%%===================================================================
%%% Reconfigure Tests
%%%===================================================================

reconfigure_tests() ->
    [
        {"encode reconfigure_response", fun() ->
            Resp = #reconfigure_response{
                return_code = 0,
                message = <<"Configuration reloaded">>,
                changed_keys = [max_job_count, slurmctld_timeout],
                version = 22050
            },
            {ok, Binary} = flurm_protocol_codec:encode_reconfigure_response(Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode reconfigure_response with non-record", fun() ->
            Result = flurm_protocol_codec:encode_reconfigure_response(not_a_record),
            ?assertMatch({ok, _}, Result)
        end}
    ].

%%%===================================================================
%%% Resource Allocation Tests
%%%===================================================================

resource_allocation_tests() ->
    [
        {"encode RESPONSE_RESOURCE_ALLOCATION with error", fun() ->
            Resp = #resource_allocation_response{
                job_id = 0,
                error_code = -1
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_RESOURCE_ALLOCATION, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode RESPONSE_RESOURCE_ALLOCATION success", fun() ->
            Resp = #resource_allocation_response{
                job_id = 5678,
                node_list = <<"node01">>,
                num_nodes = 1,
                partition = <<"batch">>,
                error_code = 0,
                job_submit_user_msg = <<"Allocated">>
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_RESOURCE_ALLOCATION, Resp),
            ?assert(is_binary(Binary))
        end}
    ].

%%%===================================================================
%%% Message Type Helper Tests
%%%===================================================================

message_type_helper_tests() ->
    [
        {"message_type_name for REQUEST_PING", fun() ->
            ?assertEqual(request_ping, flurm_protocol_codec:message_type_name(?REQUEST_PING))
        end},

        {"message_type_name for REQUEST_JOB_INFO", fun() ->
            ?assertEqual(request_job_info, flurm_protocol_codec:message_type_name(?REQUEST_JOB_INFO))
        end},

        {"message_type_name for RESPONSE_SLURM_RC", fun() ->
            ?assertEqual(response_slurm_rc, flurm_protocol_codec:message_type_name(?RESPONSE_SLURM_RC))
        end},

        {"message_type_name for REQUEST_SUBMIT_BATCH_JOB", fun() ->
            ?assertEqual(request_submit_batch_job, flurm_protocol_codec:message_type_name(?REQUEST_SUBMIT_BATCH_JOB))
        end},

        {"message_type_name for unknown", fun() ->
            ?assertMatch({unknown, 99999}, flurm_protocol_codec:message_type_name(99999))
        end},

        {"is_request for requests", fun() ->
            ?assert(flurm_protocol_codec:is_request(?REQUEST_PING)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_JOB_INFO)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_CANCEL_JOB)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_SUBMIT_BATCH_JOB)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_NODE_INFO)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_PARTITION_INFO))
        end},

        {"is_request for responses returns false", fun() ->
            ?assertNot(flurm_protocol_codec:is_request(?RESPONSE_SLURM_RC)),
            ?assertNot(flurm_protocol_codec:is_request(?RESPONSE_JOB_INFO)),
            ?assertNot(flurm_protocol_codec:is_request(?RESPONSE_SUBMIT_BATCH_JOB))
        end},

        {"is_response for responses", fun() ->
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_SLURM_RC)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_JOB_INFO)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_SUBMIT_BATCH_JOB)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_NODE_INFO)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_PARTITION_INFO))
        end},

        {"is_response for requests returns false", fun() ->
            ?assertNot(flurm_protocol_codec:is_response(?REQUEST_PING)),
            ?assertNot(flurm_protocol_codec:is_response(?REQUEST_JOB_INFO))
        end}
    ].

%%%===================================================================
%%% Decode Error Tests
%%%===================================================================

decode_error_tests() ->
    [
        {"decode empty binary", fun() ->
            Result = flurm_protocol_codec:decode(<<>>),
            ?assertMatch({error, {incomplete_length_prefix, 0}}, Result)
        end},

        {"decode incomplete length prefix", fun() ->
            Result = flurm_protocol_codec:decode(<<1, 2, 3>>),
            ?assertMatch({error, {incomplete_length_prefix, 3}}, Result)
        end},

        {"decode with length < header size", fun() ->
            Result = flurm_protocol_codec:decode(<<5:32/big, 1, 2, 3, 4, 5>>),
            ?assertMatch({error, {invalid_message_length, 5}}, Result)
        end},

        {"decode incomplete message", fun() ->
            Result = flurm_protocol_codec:decode(<<50:32/big, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10>>),
            ?assertMatch({error, {incomplete_message, 50, _}}, Result)
        end}
    ].

%%%===================================================================
%%% Protocol Resource Extraction Tests
%%%===================================================================

protocol_resource_tests() ->
    [
        {"extract_resources_from_protocol with small binary", fun() ->
            Binary = <<1, 2, 3, 4, 5>>,
            {MinNodes, MinCpus} = flurm_protocol_codec:extract_resources_from_protocol(Binary),
            ?assertEqual(0, MinNodes),
            ?assertEqual(0, MinCpus)
        end},

        {"extract_full_job_desc with small binary", fun() ->
            Binary = <<1, 2, 3, 4, 5>>,
            Result = flurm_protocol_codec:extract_full_job_desc(Binary),
            ?assertMatch({error, binary_too_small}, Result)
        end},

        {"extract_full_job_desc with valid header", fun() ->
            %% Build a binary with job_id, user_id, group_id at expected locations
            Binary = <<12345:32/big, 1000:32/big, 1000:32/big, 0:800/big>>,  % Pad to 100 bytes
            Result = flurm_protocol_codec:extract_full_job_desc(Binary),
            ?assertMatch({ok, _}, Result),
            {ok, JobDesc} = Result,
            ?assertEqual(1000, maps:get(user_id, JobDesc)),
            ?assertEqual(1000, maps:get(group_id, JobDesc))
        end}
    ].

%%%===================================================================
%%% Decode Body Tests
%%%===================================================================

decode_body_tests() ->
    [
        {"decode_body for REQUEST_PING", fun() ->
            {ok, Body} = flurm_protocol_codec:decode_body(?REQUEST_PING, <<>>),
            ?assertMatch(#ping_request{}, Body)
        end},

        {"decode_body for RESPONSE_SLURM_RC", fun() ->
            {ok, Body} = flurm_protocol_codec:decode_body(?RESPONSE_SLURM_RC, <<0:32/big-signed>>),
            ?assertEqual(0, Body#slurm_rc_response.return_code)
        end},

        {"decode_body for REQUEST_JOB_INFO", fun() ->
            Binary = <<1:32/big, 12345:32/big, 1000:32/big>>,
            {ok, Body} = flurm_protocol_codec:decode_body(?REQUEST_JOB_INFO, Binary),
            ?assertEqual(1, Body#job_info_request.show_flags),
            ?assertEqual(12345, Body#job_info_request.job_id),
            ?assertEqual(1000, Body#job_info_request.user_id)
        end},

        {"decode_body for REQUEST_CANCEL_JOB with data", fun() ->
            Body = <<12345:32/big, 0:32/big, 9:32/big, 0:32/big, 6:32/big, "12345", 0>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_CANCEL_JOB, Body),
            ?assertEqual(12345, Req#cancel_job_request.job_id),
            ?assertEqual(0, Req#cancel_job_request.step_id),
            ?assertEqual(9, Req#cancel_job_request.signal)
        end},

        {"decode_body for REQUEST_CANCEL_JOB empty", fun() ->
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_CANCEL_JOB, <<>>),
            ?assertMatch(#cancel_job_request{}, Req)
        end},

        {"decode_body for unknown message type", fun() ->
            {ok, Body} = flurm_protocol_codec:decode_body(99999, <<"raw data">>),
            ?assertEqual(<<"raw data">>, Body)
        end}
    ].

%%%===================================================================
%%% Encode Body Tests
%%%===================================================================

encode_body_tests() ->
    [
        {"encode_body for REQUEST_PING", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(?REQUEST_PING, #ping_request{}),
            ?assertEqual(<<>>, Binary)
        end},

        {"encode_body for RESPONSE_SLURM_RC", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = 42}),
            <<ReturnCode:32/big-signed>> = Binary,
            ?assertEqual(42, ReturnCode)
        end},

        {"encode_body for REQUEST_JOB_INFO", fun() ->
            Req = #job_info_request{show_flags = 1, job_id = 123, user_id = 1000},
            {ok, Binary} = flurm_protocol_codec:encode_body(?REQUEST_JOB_INFO, Req),
            ?assert(is_binary(Binary))
        end},

        {"encode_body for REQUEST_NODE_REGISTRATION_STATUS", fun() ->
            Req = #node_registration_request{status_only = true},
            {ok, Binary} = flurm_protocol_codec:encode_body(?REQUEST_NODE_REGISTRATION_STATUS, Req),
            ?assert(is_binary(Binary))
        end}
    ].

%%%===================================================================
%%% With Extra Data Tests
%%%===================================================================

with_extra_tests() ->
    [
        {"encode_with_extra REQUEST_PING", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_with_extra(?REQUEST_PING, #ping_request{}),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) >= 14)
        end},

        {"encode_with_extra with custom hostname", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_with_extra(?REQUEST_PING, #ping_request{}, <<"myhost">>),
            ?assert(is_binary(Binary))
        end},

        {"decode_with_extra roundtrip", fun() ->
            {ok, Encoded} = flurm_protocol_codec:encode_with_extra(?REQUEST_PING, #ping_request{}),
            {ok, Msg, _Extra, <<>>} = flurm_protocol_codec:decode_with_extra(Encoded),
            ?assertEqual(?REQUEST_PING, Msg#slurm_msg.header#slurm_header.msg_type)
        end}
    ].

%%%===================================================================
%%% Response Encoding/Decoding Tests
%%%===================================================================

response_tests() ->
    [
        {"encode_response RESPONSE_SLURM_RC", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_response(?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = 0}),
            ?assert(is_binary(Binary))
        end},

        {"decode_response roundtrip", fun() ->
            {ok, Encoded} = flurm_protocol_codec:encode_response(?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = 42}),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode_response(Encoded),
            ?assertEqual(?RESPONSE_SLURM_RC, Msg#slurm_msg.header#slurm_header.msg_type),
            ?assertEqual(42, (Msg#slurm_msg.body)#slurm_rc_response.return_code)
        end}
    ].

%%%===================================================================
%%% Edge Cases and Error Handling
%%%===================================================================

edge_case_tests() ->
    [
        {"encode with default record values", fun() ->
            {ok, _} = flurm_protocol_codec:encode(?REQUEST_PING, #ping_request{}),
            {ok, _} = flurm_protocol_codec:encode(?RESPONSE_SLURM_RC, #slurm_rc_response{}),
            {ok, _} = flurm_protocol_codec:encode(?REQUEST_JOB_INFO, #job_info_request{}),
            {ok, _} = flurm_protocol_codec:encode(?REQUEST_CANCEL_JOB, #cancel_job_request{}),
            {ok, _} = flurm_protocol_codec:encode(?RESPONSE_SUBMIT_BATCH_JOB, #batch_job_response{}),
            {ok, _} = flurm_protocol_codec:encode(?REQUEST_NODE_REGISTRATION_STATUS, #node_registration_request{})
        end},

        {"encode responses with empty lists", fun() ->
            {ok, _} = flurm_protocol_codec:encode(?RESPONSE_JOB_INFO, #job_info_response{jobs = []}),
            {ok, _} = flurm_protocol_codec:encode(?RESPONSE_NODE_INFO, #node_info_response{nodes = []}),
            {ok, _} = flurm_protocol_codec:encode(?RESPONSE_PARTITION_INFO, #partition_info_response{partitions = []}),
            {ok, _} = flurm_protocol_codec:encode(?RESPONSE_JOB_STEP_INFO, #job_step_info_response{steps = []}),
            {ok, _} = flurm_protocol_codec:encode(?RESPONSE_RESERVATION_INFO, #reservation_info_response{reservations = []}),
            {ok, _} = flurm_protocol_codec:encode(?RESPONSE_LICENSE_INFO, #license_info_response{licenses = []}),
            {ok, _} = flurm_protocol_codec:encode(?RESPONSE_TOPO_INFO, #topo_info_response{topos = []}),
            {ok, _} = flurm_protocol_codec:encode(?RESPONSE_FRONT_END_INFO, #front_end_info_response{front_ends = []}),
            {ok, _} = flurm_protocol_codec:encode(?RESPONSE_BURST_BUFFER_INFO, #burst_buffer_info_response{burst_buffers = []})
        end},

        {"large job_id values", fun() ->
            Req = #cancel_job_request{job_id = 16#FFFFFFFF - 1},
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_CANCEL_JOB, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(16#FFFFFFFF - 1, (Msg#slurm_msg.body)#cancel_job_request.job_id)
        end},

        {"negative return codes", fun() ->
            Resp = #slurm_rc_response{return_code = -2147483648},
            {ok, Encoded} = flurm_protocol_codec:encode(?RESPONSE_SLURM_RC, Resp),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(-2147483648, (Msg#slurm_msg.body)#slurm_rc_response.return_code)
        end},

        {"encode binary body passes through", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_PING, <<"raw binary">>),
            ?assert(is_binary(Binary))
        end}
    ].

%%%===================================================================
%%% Generated Mapping/Clause Coverage
%%%===================================================================

generated_mapping_tests() ->
    [
        {"message_type_name map", fun message_type_name_map_test/0},
        {"is_request map", fun is_request_map_test/0},
        {"is_response map", fun is_response_map_test/0},
        {"decode_body clause smoke", fun decode_body_clause_smoke_test/0},
        {"encode_body clause smoke", fun encode_body_clause_smoke_test/0}
    ].

message_type_name_map_test() ->
    MacroVals = parse_macro_values(),
    Pairs = parse_message_type_name_pairs(),
    ?assert(length(Pairs) > 10),
    lists:foreach(
      fun({Macro, ExpectedAtom}) ->
          case maps:find(Macro, MacroVals) of
              {ok, MsgType} ->
                  ?assertEqual(ExpectedAtom, flurm_protocol_codec:message_type_name(MsgType));
              error ->
                  ?assert(false)
          end
      end, Pairs),
    ?assertEqual({unknown, 999999}, flurm_protocol_codec:message_type_name(999999)).

is_request_map_test() ->
    MacroVals = parse_macro_values(),
    Macros = parse_true_macro_clauses("is_request"),
    ?assert(length(Macros) > 10),
    lists:foreach(
      fun(Macro) ->
          case maps:find(Macro, MacroVals) of
              {ok, MsgType} -> ?assertEqual(true, flurm_protocol_codec:is_request(MsgType));
              error -> ?assert(false)
          end
      end, Macros),
    ?assertEqual(true, flurm_protocol_codec:is_request(1001)),
    ?assertEqual(true, flurm_protocol_codec:is_request(1029)),
    ?assertEqual(false, flurm_protocol_codec:is_request(1030)),
    ?assertEqual(false, flurm_protocol_codec:is_request(0)).

is_response_map_test() ->
    MacroVals = parse_macro_values(),
    Macros = parse_true_macro_clauses("is_response"),
    ?assert(length(Macros) > 10),
    lists:foreach(
      fun(Macro) ->
          case maps:find(Macro, MacroVals) of
              {ok, MsgType} -> ?assertEqual(true, flurm_protocol_codec:is_response(MsgType));
              error -> ?assert(false)
          end
      end, Macros),
    ?assertEqual(false, flurm_protocol_codec:is_response(0)).

decode_body_clause_smoke_test() ->
    MacroVals = parse_macro_values(),
    Macros = parse_decode_body_macros(),
    ?assert(length(Macros) > 20),
    lists:foreach(
      fun(Macro) ->
          case maps:find(Macro, MacroVals) of
              {ok, MsgType} ->
                  _ = catch flurm_protocol_codec:decode_body(MsgType, <<>>),
                  ok;
              error ->
                  ?assert(false)
          end
      end, Macros).

encode_body_clause_smoke_test() ->
    MacroVals = parse_macro_values(),
    Macros = parse_encode_body_variable_macros(),
    ?assert(length(Macros) > 20),
    lists:foreach(
      fun(Macro) ->
          case maps:find(Macro, MacroVals) of
              {ok, MsgType} ->
                  _ = catch flurm_protocol_codec:encode_body(MsgType, <<>>),
                  ok;
              error ->
                  ?assert(false)
          end
      end, Macros).

%%%===================================================================
%%% Time Parsing Tests
%%%===================================================================

time_parsing_tests() ->
    [
        {"parse time from script HH:MM:SS format", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --time=01:30:00\necho hello">>,
            %% Decode body to exercise time parsing
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            %% Time limit should be parsed from script
            ?assert(is_record(Req, batch_job_request))
        end},

        {"parse time from script MM:SS format", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --time=30:00\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assert(is_record(Req, batch_job_request))
        end},

        {"parse time from script minutes format", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --time=60\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assert(is_record(Req, batch_job_request))
        end},

        {"parse time from script D-HH:MM:SS format", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --time=1-00:00:00\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assert(is_record(Req, batch_job_request))
        end},

        {"parse time -t short option", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH -t 120\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assert(is_record(Req, batch_job_request))
        end}
    ].

%%%===================================================================
%%% Resource Extraction Tests
%%%===================================================================

resource_extraction_tests() ->
    [
        {"extract nodes from script --nodes=", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --nodes=4\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(4, Req#batch_job_request.min_nodes)
        end},

        {"extract nodes from script -N", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH -N 8\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(8, Req#batch_job_request.min_nodes)
        end},

        {"extract cpus-per-task from script", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --cpus-per-task=16\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(16, Req#batch_job_request.cpus_per_task)
        end},

        {"extract ntasks from script", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --ntasks=32\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(32, Req#batch_job_request.num_tasks)
        end},

        {"extract memory from script --mem=", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --mem=4G\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(4096, Req#batch_job_request.min_mem_per_node)
        end},

        {"extract resources from protocol binary", fun() ->
            %% Build a minimal binary that looks like a job descriptor
            Binary = <<0:800/big>>,  % 100 bytes of zeros
            {MinNodes, MinCpus} = flurm_protocol_codec:extract_resources_from_protocol(Binary),
            ?assert(is_integer(MinNodes)),
            ?assert(is_integer(MinCpus))
        end}
    ].

%%%===================================================================
%%% String Helper Tests
%%%===================================================================

string_helper_tests() ->
    [
        {"extract job name from script", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --job-name=test_job\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"test_job">>, Req#batch_job_request.name)
        end},

        {"extract job name -J short option", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH -J my_job\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"my_job">>, Req#batch_job_request.name)
        end},

        {"extract partition from script", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --partition=gpu\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"gpu">>, Req#batch_job_request.partition)
        end}
    ].

%%%===================================================================
%%% Auth Section Tests
%%%===================================================================

auth_section_tests() ->
    [
        {"strip_auth_section too short", fun() ->
            Binary = <<1, 2, 3, 4, 5>>,
            Result = flurm_protocol_codec:strip_auth_section(Binary),
            ?assertMatch({error, {auth_section_too_short, 5}}, Result)
        end},

        {"strip_auth_section credential too short", fun() ->
            %% Plugin ID + credential length claiming more data than available
            Binary = <<101:32/big, 1000:32/big, 1, 2, 3>>,
            Result = flurm_protocol_codec:strip_auth_section(Binary),
            ?assertMatch({error, {auth_cred_too_short, 1000}}, Result)
        end},

        {"strip_auth_section success", fun() ->
            %% Plugin ID 101 (MUNGE), credential length 4, credential, then body
            Binary = <<101:32/big, 4:32/big, "cred", "body data">>,
            Result = flurm_protocol_codec:strip_auth_section(Binary),
            ?assertMatch({ok, <<"body data">>, _}, Result),
            {ok, Body, AuthInfo} = Result,
            ?assertEqual(<<"body data">>, Body),
            ?assertEqual(munge, maps:get(auth_type, AuthInfo)),
            ?assertEqual(101, maps:get(plugin_id, AuthInfo))
        end},

        {"strip_auth_section unknown plugin", fun() ->
            Binary = <<999:32/big, 2:32/big, "AB", "data">>,
            Result = flurm_protocol_codec:strip_auth_section(Binary),
            ?assertMatch({ok, <<"data">>, _}, Result),
            {ok, _, AuthInfo} = Result,
            ?assertEqual(unknown, maps:get(auth_type, AuthInfo))
        end}
    ].

%%%===================================================================
%%% Header Integration Tests
%%%===================================================================

header_integration_tests() ->
    [
        {"encode includes proper header", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_PING, #ping_request{}),
            <<Length:32/big, _Rest/binary>> = Binary,
            ?assert(Length >= ?SLURM_HEADER_SIZE_MIN)
        end},

        {"multiple messages can be decoded from stream", fun() ->
            {ok, Msg1} = flurm_protocol_codec:encode(?REQUEST_PING, #ping_request{}),
            {ok, Msg2} = flurm_protocol_codec:encode(?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = 0}),
            Combined = <<Msg1/binary, Msg2/binary>>,
            {ok, Decoded1, Rest} = flurm_protocol_codec:decode(Combined),
            ?assertEqual(?REQUEST_PING, Decoded1#slurm_msg.header#slurm_header.msg_type),
            {ok, Decoded2, <<>>} = flurm_protocol_codec:decode(Rest),
            ?assertEqual(?RESPONSE_SLURM_RC, Decoded2#slurm_msg.header#slurm_header.msg_type)
        end}
    ].

%%%===================================================================
%%% Full Roundtrip Tests
%%%===================================================================

full_roundtrip_tests() ->
    [
        {"roundtrip REQUEST_JOB_INFO various values", fun() ->
            TestCases = [
                #job_info_request{show_flags = 0, job_id = 0, user_id = 0},
                #job_info_request{show_flags = 1, job_id = 100, user_id = 1000},
                #job_info_request{show_flags = 16#FFFF, job_id = 16#FFFFFFFF - 2, user_id = 65535}
            ],
            lists:foreach(fun(Req) ->
                {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_JOB_INFO, Req),
                {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
                Body = Msg#slurm_msg.body,
                ?assertEqual(Req#job_info_request.show_flags, Body#job_info_request.show_flags),
                ?assertEqual(Req#job_info_request.job_id, Body#job_info_request.job_id),
                ?assertEqual(Req#job_info_request.user_id, Body#job_info_request.user_id)
            end, TestCases)
        end},

        {"roundtrip RESPONSE_SLURM_RC various codes", fun() ->
            TestCodes = [0, 1, -1, 100, -100, 2147483647, -2147483648],
            lists:foreach(fun(Code) ->
                Resp = #slurm_rc_response{return_code = Code},
                {ok, Encoded} = flurm_protocol_codec:encode(?RESPONSE_SLURM_RC, Resp),
                {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
                ?assertEqual(Code, (Msg#slurm_msg.body)#slurm_rc_response.return_code)
            end, TestCodes)
        end},

        {"roundtrip batch job response", fun() ->
            Resp = #batch_job_response{
                job_id = 12345,
                step_id = 0,
                error_code = 0,
                job_submit_user_msg = <<"Job submitted successfully">>
            },
            {ok, Encoded} = flurm_protocol_codec:encode(?RESPONSE_SUBMIT_BATCH_JOB, Resp),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            Body = Msg#slurm_msg.body,
            ?assertEqual(12345, Body#batch_job_response.job_id),
            ?assertEqual(0, Body#batch_job_response.step_id),
            ?assertEqual(0, Body#batch_job_response.error_code)
        end}
    ].

%%%===================================================================
%%% Cancel Job Tests
%%%===================================================================

cancel_job_tests() ->
    [
        {"decode cancel job minimal", fun() ->
            Binary = <<1234:32/big>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_CANCEL_JOB, Binary),
            ?assertEqual(1234, Req#cancel_job_request.job_id)
        end},

        {"decode cancel job with step and signal", fun() ->
            Binary = <<5678:32/big, 2:32/big, 15:32/big>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_CANCEL_JOB, Binary),
            ?assertEqual(5678, Req#cancel_job_request.job_id),
            ?assertEqual(2, Req#cancel_job_request.step_id),
            ?assertEqual(15, Req#cancel_job_request.signal)
        end},

        {"encode cancel job roundtrip", fun() ->
            Req = #cancel_job_request{
                job_id = 99999,
                job_id_str = <<"99999">>,
                step_id = 5,
                signal = 9,
                flags = 1
            },
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_CANCEL_JOB, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            Body = Msg#slurm_msg.body,
            ?assertEqual(99999, Body#cancel_job_request.job_id),
            ?assertEqual(5, Body#cancel_job_request.step_id),
            ?assertEqual(9, Body#cancel_job_request.signal),
            ?assertEqual(1, Body#cancel_job_request.flags)
        end}
    ].

%%%===================================================================
%%% Suspend/Signal Tests
%%%===================================================================

suspend_signal_tests() ->
    [
        {"decode suspend request", fun() ->
            Binary = <<12345:32/big, 1:16/big>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUSPEND, Binary),
            ?assertEqual(12345, Req#suspend_request.job_id),
            ?assertEqual(true, Req#suspend_request.suspend)
        end},

        {"decode resume request", fun() ->
            Binary = <<12345:32/big, 0:16/big>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUSPEND, Binary),
            ?assertEqual(12345, Req#suspend_request.job_id),
            ?assertEqual(false, Req#suspend_request.suspend)
        end},

        {"decode signal job request", fun() ->
            Binary = <<99999:32/big, (-1):32/big-signed, 15:16/big, 0:16/big>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SIGNAL_JOB, Binary),
            ?assertEqual(99999, Req#signal_job_request.job_id),
            ?assertEqual(-1, Req#signal_job_request.step_id),
            ?assertEqual(15, Req#signal_job_request.signal)
        end}
    ].

%%%===================================================================
%%% Script Parsing Tests
%%%===================================================================

script_parsing_tests() ->
    [
        {"parse script with multiple SBATCH directives", fun() ->
            Script = <<"#!/bin/bash\n",
                       "#SBATCH --job-name=multi_test\n",
                       "#SBATCH --nodes=4\n",
                       "#SBATCH --ntasks=16\n",
                       "#SBATCH --time=01:00:00\n",
                       "#SBATCH --partition=compute\n",
                       "echo hello\n">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"multi_test">>, Req#batch_job_request.name),
            ?assertEqual(4, Req#batch_job_request.min_nodes),
            ?assertEqual(16, Req#batch_job_request.num_tasks),
            ?assertEqual(<<"compute">>, Req#batch_job_request.partition)
        end},

        {"parse script stops at non-comment line", fun() ->
            Script = <<"#!/bin/bash\n",
                       "#SBATCH --job-name=first\n",
                       "echo command\n",
                       "#SBATCH --job-name=second\n">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            %% First directive wins, parsing stops at echo
            ?assertEqual(<<"first">>, Req#batch_job_request.name)
        end},

        {"parse script with blank lines", fun() ->
            Script = <<"#!/bin/bash\n",
                       "\n",
                       "#SBATCH --job-name=blank_test\n",
                       "\n",
                       "#SBATCH --nodes=2\n",
                       "\n",
                       "echo hello\n">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"blank_test">>, Req#batch_job_request.name),
            ?assertEqual(2, Req#batch_job_request.min_nodes)
        end}
    ].

%%%===================================================================
%%% Memory Parsing Tests
%%%===================================================================

memory_parsing_tests() ->
    [
        {"parse memory in megabytes", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --mem=1024\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(1024, Req#batch_job_request.min_mem_per_node)
        end},

        {"parse memory with M suffix", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --mem=512M\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(512, Req#batch_job_request.min_mem_per_node)
        end},

        {"parse memory with G suffix", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --mem=8G\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(8192, Req#batch_job_request.min_mem_per_node)
        end},

        {"parse memory with K suffix", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --mem=2048K\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(2, Req#batch_job_request.min_mem_per_node)
        end}
    ].

%%%===================================================================
%%% Array Spec Tests
%%%===================================================================

array_spec_tests() ->
    [
        {"parse array spec from script", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --array=0-10\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"0-10">>, Req#batch_job_request.array_inx)
        end},

        {"parse array spec with step", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --array=0-100:10\necho hello">>,
            {ok, _Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script))
        end},

        {"parse array spec with percent limit", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --array=1-50%5\necho hello">>,
            {ok, _Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script))
        end}
    ].

%%%===================================================================
%%% Node Registration Tests
%%%===================================================================

node_registration_tests() ->
    [
        {"encode/decode node registration status_only=true", fun() ->
            Req = #node_registration_request{status_only = true},
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_NODE_REGISTRATION_STATUS, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(true, (Msg#slurm_msg.body)#node_registration_request.status_only)
        end},

        {"encode/decode node registration status_only=false", fun() ->
            Req = #node_registration_request{status_only = false},
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_NODE_REGISTRATION_STATUS, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(false, (Msg#slurm_msg.body)#node_registration_request.status_only)
        end},

        {"decode node registration empty body", fun() ->
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_NODE_REGISTRATION_STATUS, <<>>),
            ?assertEqual(false, Req#node_registration_request.status_only)
        end},

        {"decode node registration nonzero byte", fun() ->
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_NODE_REGISTRATION_STATUS, <<1, 2, 3>>),
            ?assertEqual(true, Req#node_registration_request.status_only)
        end}
    ].

%%%===================================================================
%%% Partition Info Tests
%%%===================================================================

partition_info_tests() ->
    [
        {"encode partition info response with multiple partitions", fun() ->
            Part1 = #partition_info{name = <<"batch">>, total_nodes = 100, total_cpus = 6400},
            Part2 = #partition_info{name = <<"gpu">>, total_nodes = 10, total_cpus = 400},
            Resp = #partition_info_response{
                last_update = erlang:system_time(second),
                partition_count = 2,
                partitions = [Part1, Part2]
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_PARTITION_INFO, Resp),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) > 50)
        end},

        {"encode partition request with partition name", fun() ->
            Req = #partition_info_request{show_flags = 1, partition_name = <<"compute">>},
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_PARTITION_INFO, Req),
            ?assert(is_binary(Binary))
        end}
    ].

%%%===================================================================
%%% Comprehensive decode_body Tests
%%%===================================================================

decode_body_comprehensive_tests() ->
    [
        {"decode_body REQUEST_PING with non-empty body", fun() ->
            {ok, Body} = flurm_protocol_codec:decode_body(?REQUEST_PING, <<"extra data">>),
            ?assertMatch(#ping_request{}, Body)
        end},

        {"decode_body RESPONSE_SLURM_RC empty body", fun() ->
            {ok, Body} = flurm_protocol_codec:decode_body(?RESPONSE_SLURM_RC, <<>>),
            ?assertEqual(0, Body#slurm_rc_response.return_code)
        end},

        {"decode_body REQUEST_JOB_INFO partial data", fun() ->
            {ok, Body} = flurm_protocol_codec:decode_body(?REQUEST_JOB_INFO, <<5:32/big>>),
            ?assertEqual(5, Body#job_info_request.show_flags),
            ?assertEqual(0, Body#job_info_request.job_id)
        end},

        {"decode_body REQUEST_JOB_INFO two fields", fun() ->
            {ok, Body} = flurm_protocol_codec:decode_body(?REQUEST_JOB_INFO, <<3:32/big, 999:32/big>>),
            ?assertEqual(3, Body#job_info_request.show_flags),
            ?assertEqual(999, Body#job_info_request.job_id)
        end},

        {"decode_body REQUEST_JOB_INFO empty", fun() ->
            {ok, Body} = flurm_protocol_codec:decode_body(?REQUEST_JOB_INFO, <<>>),
            ?assertMatch(#job_info_request{}, Body)
        end},

        {"decode_body REQUEST_BUILD_INFO", fun() ->
            {ok, Body} = flurm_protocol_codec:decode_body(?REQUEST_BUILD_INFO, <<"ignored">>),
            ?assertEqual(#{}, Body)
        end},

        {"decode_body REQUEST_CONFIG_INFO", fun() ->
            {ok, Body} = flurm_protocol_codec:decode_body(?REQUEST_CONFIG_INFO, <<"ignored">>),
            ?assertEqual(#{}, Body)
        end}
    ].

%%%===================================================================
%%% Comprehensive encode_body Tests
%%%===================================================================

encode_body_comprehensive_tests() ->
    [
        {"encode_body raw binary passthrough", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(99999, <<"pass through">>),
            ?assertEqual(<<"pass through">>, Binary)
        end},

        {"encode_body unsupported message type with non-binary", fun() ->
            Result = flurm_protocol_codec:encode_body(99999, not_a_binary),
            ?assertMatch({error, {unsupported_message_type, 99999, not_a_binary}}, Result)
        end},

        {"encode_body REQUEST_NODE_INFO with non-record", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(?REQUEST_NODE_INFO, not_a_record),
            ?assertEqual(<<0:32/big, 0:32/big>>, Binary)
        end},

        {"encode_body REQUEST_PARTITION_INFO with non-record", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(?REQUEST_PARTITION_INFO, not_a_record),
            ?assertEqual(<<0:32/big, 0:32/big>>, Binary)
        end}
    ].

%%%===================================================================
%%% Response Encoding Tests
%%%===================================================================

response_encoding_tests() ->
    [
        {"encode_response_no_auth", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_response_no_auth(
                ?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = 0}),
            ?assert(is_binary(Binary)),
            %% Should have SLURM_NO_AUTH_CRED flag in header
            <<_Length:32/big, _Version:16/big, Flags:16/big, _Rest/binary>> = Binary,
            ?assertEqual(?SLURM_NO_AUTH_CRED, Flags band ?SLURM_NO_AUTH_CRED)
        end},

        {"encode_response_proper_auth", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_response_proper_auth(
                ?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = 42}),
            ?assert(is_binary(Binary))
        end},

        {"encode job_ready_response with map", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_JOB_READY, #{return_code => 0}),
            ?assertEqual(<<0:32/big-signed>>, Binary)
        end},

        {"encode job_ready_response with integer", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_JOB_READY, 1),
            ?assertEqual(<<1:32/big-signed>>, Binary)
        end}
    ].

%%%===================================================================
%%% Job Info Request Tests
%%%===================================================================

job_info_request_tests() ->
    [
        {"encode job_info_request all fields", fun() ->
            Req = #job_info_request{show_flags = 16#FFFF, job_id = 16#FFFFFFFF - 2, user_id = 65534},
            {ok, Binary} = flurm_protocol_codec:encode_body(?REQUEST_JOB_INFO, Req),
            <<ShowFlags:32/big, JobId:32/big, UserId:32/big>> = Binary,
            ?assertEqual(16#FFFF, ShowFlags),
            ?assertEqual(16#FFFFFFFF - 2, JobId),
            ?assertEqual(65534, UserId)
        end}
    ].

%%%===================================================================
%%% Batch Job Decode Tests
%%%===================================================================

batch_job_decode_tests() ->
    [
        {"decode batch job with PWD environment", fun() ->
            %% Binary containing PWD=/home/user
            Script = <<"#!/bin/bash\necho hello">>,
            %% Add PWD to the binary
            EnvPart = <<"PWD=/home/testuser", 0>>,
            Binary = build_batch_job_binary_with_env(Script, EnvPart),
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB, Binary),
            ?assertEqual(<<"/home/testuser">>, Req#batch_job_request.work_dir)
        end},

        {"decode batch job extract stdout path", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --output=/tmp/job_%j.out\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"/tmp/job_%j.out">>, Req#batch_job_request.std_out)
        end},

        {"decode batch job extract stderr path", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --error=/tmp/job_%j.err\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"/tmp/job_%j.err">>, Req#batch_job_request.std_err)
        end}
    ].

%%%===================================================================
%%% Error Path Tests
%%%===================================================================

error_path_tests() ->
    [
        {"decode_with_extra incomplete", fun() ->
            Result = flurm_protocol_codec:decode_with_extra(<<1, 2, 3>>),
            ?assertMatch({error, {incomplete_length_prefix, 3}}, Result)
        end},

        {"decode_with_extra incomplete message", fun() ->
            Result = flurm_protocol_codec:decode_with_extra(<<100:32/big, 1, 2, 3, 4, 5>>),
            ?assertMatch({error, {incomplete_message, 100, 5}}, Result)
        end},

        {"decode_response incomplete", fun() ->
            Result = flurm_protocol_codec:decode_response(<<1, 2>>),
            ?assertMatch({error, {incomplete_length_prefix, 2}}, Result)
        end},

        {"decode_response incomplete message", fun() ->
            Result = flurm_protocol_codec:decode_response(<<200:32/big, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10>>),
            ?assertMatch({error, {incomplete_message, 200, 10}}, Result)
        end}
    ].

%%%===================================================================
%%% Binary Scanning Tests
%%%===================================================================

binary_scanning_tests() ->
    [
        {"extract_resources_from_protocol medium binary", fun() ->
            %% 200 bytes of test data
            Binary = list_to_binary(lists:duplicate(200, 0)),
            {MinNodes, MinCpus} = flurm_protocol_codec:extract_resources_from_protocol(Binary),
            ?assert(is_integer(MinNodes)),
            ?assert(is_integer(MinCpus))
        end},

        {"extract_full_job_desc minimum size", fun() ->
            Binary = list_to_binary(lists:duplicate(50, 0)),
            Result = flurm_protocol_codec:extract_full_job_desc(Binary),
            ?assertMatch({ok, _}, Result)
        end}
    ].

%%%===================================================================
%%% Dispatch Logic Tests
%%%===================================================================

dispatch_logic_tests() ->
    [
        {"dispatch decode_body to correct handler for each message type", fun() ->
            %% Test that decode_body dispatches correctly for known message types
            MessageTypes = [
                {?REQUEST_PING, <<>>},
                {?REQUEST_NODE_REGISTRATION_STATUS, <<>>},
                {?REQUEST_JOB_INFO, <<>>},
                {?REQUEST_CANCEL_JOB, <<>>},
                {?RESPONSE_SLURM_RC, <<0:32/big-signed>>}
            ],
            lists:foreach(fun({MsgType, Body}) ->
                Result = flurm_protocol_codec:decode_body(MsgType, Body),
                ?assertMatch({ok, _}, Result)
            end, MessageTypes)
        end},

        {"dispatch encode_body to correct handler for each message type", fun() ->
            %% Test encode_body dispatch for known records
            Records = [
                {?REQUEST_PING, #ping_request{}},
                {?REQUEST_NODE_REGISTRATION_STATUS, #node_registration_request{}},
                {?REQUEST_JOB_INFO, #job_info_request{}},
                {?REQUEST_CANCEL_JOB, #cancel_job_request{}},
                {?RESPONSE_SLURM_RC, #slurm_rc_response{}}
            ],
            lists:foreach(fun({MsgType, Record}) ->
                Result = flurm_protocol_codec:encode_body(MsgType, Record),
                ?assertMatch({ok, _}, Result)
            end, Records)
        end}
    ].

%%%===================================================================
%%% Message Type Boundary Tests
%%%===================================================================

message_type_boundary_tests() ->
    [
        {"is_request boundary 1001-1029", fun() ->
            ?assert(flurm_protocol_codec:is_request(1001)),
            ?assert(flurm_protocol_codec:is_request(1015)),
            ?assert(flurm_protocol_codec:is_request(1029)),
            ?assertNot(flurm_protocol_codec:is_request(1000)),
            ?assertNot(flurm_protocol_codec:is_request(1030))
        end},

        {"is_request specific message types", fun() ->
            ?assert(flurm_protocol_codec:is_request(?REQUEST_RECONFIGURE)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_SHUTDOWN)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_BUILD_INFO)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_RESOURCE_ALLOCATION)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_KILL_JOB))
        end},

        {"is_response specific message types", fun() ->
            ?assert(flurm_protocol_codec:is_response(?MESSAGE_NODE_REGISTRATION_STATUS)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_BUILD_INFO)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_RESOURCE_ALLOCATION)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_CANCEL_JOB_STEP)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_SLURM_RC_MSG))
        end}
    ].

%%%===================================================================
%%% Large Value Tests
%%%===================================================================

large_value_tests() ->
    [
        {"handle max uint32 job_id", fun() ->
            Req = #cancel_job_request{job_id = 16#FFFFFFFD},  % Just under NO_VAL
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_CANCEL_JOB, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(16#FFFFFFFD, (Msg#slurm_msg.body)#cancel_job_request.job_id)
        end},

        {"handle large time values", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --time=7-00:00:00\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            %% 7 days = 7 * 86400 = 604800 seconds
            ?assertEqual(604800, Req#batch_job_request.time_limit)
        end},

        {"handle large node counts", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --nodes=10000\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(10000, Req#batch_job_request.min_nodes)
        end}
    ].

%%%===================================================================
%%% Federation Message Tests
%%%===================================================================

federation_message_tests() ->
    [
        {"message_type_name federation requests", fun() ->
            ?assertEqual(request_fed_info, flurm_protocol_codec:message_type_name(?REQUEST_FED_INFO)),
            ?assertEqual(response_fed_info, flurm_protocol_codec:message_type_name(?RESPONSE_FED_INFO)),
            ?assertEqual(request_federation_submit, flurm_protocol_codec:message_type_name(?REQUEST_FEDERATION_SUBMIT)),
            ?assertEqual(response_federation_submit, flurm_protocol_codec:message_type_name(?RESPONSE_FEDERATION_SUBMIT))
        end},

        {"is_request federation types", fun() ->
            ?assert(flurm_protocol_codec:is_request(?REQUEST_FED_INFO)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_FEDERATION_SUBMIT)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_FEDERATION_JOB_STATUS)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_FEDERATION_JOB_CANCEL)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_UPDATE_FEDERATION))
        end},

        {"is_response federation types", fun() ->
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_FED_INFO)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_FEDERATION_SUBMIT)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_FEDERATION_JOB_STATUS)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_FEDERATION_JOB_CANCEL)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_UPDATE_FEDERATION))
        end}
    ].

%%%===================================================================
%%% srun Callback Tests
%%%===================================================================

srun_callback_tests() ->
    [
        {"encode SRUN_JOB_COMPLETE", fun() ->
            Msg = #srun_job_complete{job_id = 12345, step_id = 0},
            {ok, Binary} = flurm_protocol_codec:encode_body(?SRUN_JOB_COMPLETE, Msg),
            <<JobId:32/big, StepId:32/big, StepHetComp:32/big>> = Binary,
            ?assertEqual(12345, JobId),
            ?assertEqual(0, StepId),
            ?assertEqual(0, StepHetComp)
        end},

        {"encode SRUN_PING empty body", fun() ->
            Msg = #srun_ping{},
            {ok, Binary} = flurm_protocol_codec:encode_body(?SRUN_PING, Msg),
            ?assertEqual(<<>>, Binary)
        end}
    ].

%%%===================================================================
%%% Encode Response Variants Tests
%%%===================================================================

encode_response_variants_tests() ->
    [
        {"encode_response includes auth section", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_response(
                ?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = 0}),
            %% Should be larger than just header + body due to auth section
            ?assert(byte_size(Binary) > 24)
        end},

        {"encode_response_no_auth smaller than with auth", fun() ->
            {ok, WithAuth} = flurm_protocol_codec:encode_response(
                ?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = 0}),
            {ok, NoAuth} = flurm_protocol_codec:encode_response_no_auth(
                ?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = 0}),
            ?assert(byte_size(NoAuth) < byte_size(WithAuth))
        end},

        {"encode RESPONSE_JOB_ALLOCATION_INFO same as RESPONSE_RESOURCE_ALLOCATION", fun() ->
            Resp = #resource_allocation_response{job_id = 999, node_list = <<"node01">>},
            {ok, Bin1} = flurm_protocol_codec:encode_body(?RESPONSE_RESOURCE_ALLOCATION, Resp),
            {ok, Bin2} = flurm_protocol_codec:encode_body(?RESPONSE_JOB_ALLOCATION_INFO, Resp),
            ?assertEqual(Bin1, Bin2)
        end}
    ].

%%%===================================================================
%%% Comprehensive Time Parsing Tests
%%%===================================================================

comprehensive_time_parsing_tests() ->
    [
        {"parse HH:MM:SS - standard format", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --time=02:30:45\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            %% 2*3600 + 30*60 + 45 = 9045 seconds
            ?assertEqual(9045, Req#batch_job_request.time_limit)
        end},

        {"parse MM:SS - short format", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --time=45:30\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            %% 45*60 + 30 = 2730 seconds
            ?assertEqual(2730, Req#batch_job_request.time_limit)
        end},

        {"parse minutes only", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --time=120\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            %% 120 minutes = 7200 seconds
            ?assertEqual(7200, Req#batch_job_request.time_limit)
        end},

        {"parse D-HH:MM:SS - full day format", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --time=2-12:30:00\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            %% 2*86400 + 12*3600 + 30*60 = 172800 + 43200 + 1800 = 217800 seconds
            ?assertEqual(217800, Req#batch_job_request.time_limit)
        end},

        {"parse D-HH:MM - day without seconds", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --time=3-06:15\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            %% 3*86400 + 6*3600 + 15*60 = 281700 seconds
            ?assertEqual(281700, Req#batch_job_request.time_limit)
        end},

        {"parse -t short flag with space", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH -t 30\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            %% 30 minutes = 1800 seconds
            ?assertEqual(1800, Req#batch_job_request.time_limit)
        end},

        {"parse time with 00 prefix hours", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --time=00:45:00\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            %% 45*60 = 2700 seconds
            ?assertEqual(2700, Req#batch_job_request.time_limit)
        end},

        {"parse very long time (1 week)", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --time=7-00:00:00\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            %% 7*86400 = 604800 seconds
            ?assertEqual(604800, Req#batch_job_request.time_limit)
        end}
    ].

%%%===================================================================
%%% Comprehensive Resource Extraction Tests
%%%===================================================================

comprehensive_resource_extraction_tests() ->
    [
        {"extract --nodes= with various values", fun() ->
            lists:foreach(fun(N) ->
                Script = iolist_to_binary([<<"#!/bin/bash\n#SBATCH --nodes=">>,
                    integer_to_binary(N), <<"\necho hello">>]),
                {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                    build_batch_job_binary(Script)),
                ?assertEqual(N, Req#batch_job_request.min_nodes)
            end, [1, 2, 4, 8, 16, 32, 64, 128, 256, 1000])
        end},

        {"extract -N with various values", fun() ->
            lists:foreach(fun(N) ->
                Script = iolist_to_binary([<<"#!/bin/bash\n#SBATCH -N ">>,
                    integer_to_binary(N), <<"\necho hello">>]),
                {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                    build_batch_job_binary(Script)),
                ?assertEqual(N, Req#batch_job_request.min_nodes)
            end, [1, 5, 10, 50, 100])
        end},

        {"extract -N without space (adjacent digit)", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH -N4\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(4, Req#batch_job_request.min_nodes)
        end},

        {"extract --ntasks= with various values", fun() ->
            lists:foreach(fun(N) ->
                Script = iolist_to_binary([<<"#!/bin/bash\n#SBATCH --ntasks=">>,
                    integer_to_binary(N), <<"\necho hello">>]),
                {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                    build_batch_job_binary(Script)),
                ?assertEqual(N, Req#batch_job_request.num_tasks)
            end, [1, 4, 16, 64, 128, 256])
        end},

        {"extract -n with various values", fun() ->
            lists:foreach(fun(N) ->
                Script = iolist_to_binary([<<"#!/bin/bash\n#SBATCH -n ">>,
                    integer_to_binary(N), <<"\necho hello">>]),
                {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                    build_batch_job_binary(Script)),
                ?assertEqual(N, Req#batch_job_request.num_tasks)
            end, [1, 8, 32])
        end},

        {"extract -n without space (adjacent digit)", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH -n16\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(16, Req#batch_job_request.num_tasks)
        end},

        {"extract --cpus-per-task= with various values", fun() ->
            lists:foreach(fun(N) ->
                Script = iolist_to_binary([<<"#!/bin/bash\n#SBATCH --cpus-per-task=">>,
                    integer_to_binary(N), <<"\necho hello">>]),
                {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                    build_batch_job_binary(Script)),
                ?assertEqual(N, Req#batch_job_request.cpus_per_task)
            end, [1, 2, 4, 8, 16, 32, 64])
        end},

        {"extract -c with various values", fun() ->
            lists:foreach(fun(N) ->
                Script = iolist_to_binary([<<"#!/bin/bash\n#SBATCH -c ">>,
                    integer_to_binary(N), <<"\necho hello">>]),
                {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                    build_batch_job_binary(Script)),
                ?assertEqual(N, Req#batch_job_request.cpus_per_task)
            end, [1, 4, 12])
        end},

        {"extract -c without space (adjacent digit)", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH -c8\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(8, Req#batch_job_request.cpus_per_task)
        end},

        {"combined resources - nodes, tasks, cpus", fun() ->
            Script = <<"#!/bin/bash\n",
                       "#SBATCH --nodes=4\n",
                       "#SBATCH --ntasks=16\n",
                       "#SBATCH --cpus-per-task=2\n",
                       "echo hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(4, Req#batch_job_request.min_nodes),
            ?assertEqual(16, Req#batch_job_request.num_tasks),
            ?assertEqual(2, Req#batch_job_request.cpus_per_task)
        end}
    ].

%%%===================================================================
%%% Comprehensive Memory Parsing Tests
%%%===================================================================

comprehensive_memory_tests() ->
    [
        {"parse --mem= in MB (no suffix)", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --mem=2048\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(2048, Req#batch_job_request.min_mem_per_node)
        end},

        {"parse --mem= with M suffix", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --mem=1024M\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(1024, Req#batch_job_request.min_mem_per_node)
        end},

        {"parse --mem= with lowercase m suffix", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --mem=256m\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(256, Req#batch_job_request.min_mem_per_node)
        end},

        {"parse --mem= with G suffix (converts to MB)", fun() ->
            lists:foreach(fun({GVal, ExpectedMB}) ->
                Script = iolist_to_binary([<<"#!/bin/bash\n#SBATCH --mem=">>,
                    integer_to_binary(GVal), <<"G\necho hello">>]),
                {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                    build_batch_job_binary(Script)),
                ?assertEqual(ExpectedMB, Req#batch_job_request.min_mem_per_node)
            end, [{1, 1024}, {2, 2048}, {4, 4096}, {8, 8192}, {16, 16384}])
        end},

        {"parse --mem= with lowercase g suffix", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --mem=4g\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(4096, Req#batch_job_request.min_mem_per_node)
        end},

        {"parse --mem= with K suffix (converts to MB)", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --mem=4096K\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            %% 4096K = 4MB
            ?assertEqual(4, Req#batch_job_request.min_mem_per_node)
        end},

        {"parse --mem= with lowercase k suffix", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --mem=8192k\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            %% 8192K = 8MB
            ?assertEqual(8, Req#batch_job_request.min_mem_per_node)
        end}
    ].

%%%===================================================================
%%% Comprehensive Job Name Extraction Tests
%%%===================================================================

comprehensive_job_name_tests() ->
    [
        {"extract --job-name= with simple name", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --job-name=simple\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"simple">>, Req#batch_job_request.name)
        end},

        {"extract --job-name= with underscore", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --job-name=my_job_name\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"my_job_name">>, Req#batch_job_request.name)
        end},

        {"extract --job-name= with dashes", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --job-name=my-test-job\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"my-test-job">>, Req#batch_job_request.name)
        end},

        {"extract -J with space", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH -J short_name\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"short_name">>, Req#batch_job_request.name)
        end},

        {"extract job name with numbers", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --job-name=test123job\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"test123job">>, Req#batch_job_request.name)
        end},

        {"first job name directive wins", fun() ->
            Script = <<"#!/bin/bash\n",
                       "#SBATCH --job-name=first_name\n",
                       "#SBATCH --job-name=second_name\n",
                       "echo hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"first_name">>, Req#batch_job_request.name)
        end}
    ].

%%%===================================================================
%%% Comprehensive Partition Extraction Tests
%%%===================================================================

comprehensive_partition_tests() ->
    [
        {"extract --partition= with simple name", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --partition=batch\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"batch">>, Req#batch_job_request.partition)
        end},

        {"extract --partition= with gpu partition", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --partition=gpu\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"gpu">>, Req#batch_job_request.partition)
        end},

        {"extract -p short flag with space", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH -p compute\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"compute">>, Req#batch_job_request.partition)
        end},

        {"extract partition with underscore", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --partition=high_mem\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"high_mem">>, Req#batch_job_request.partition)
        end}
    ].

%%%===================================================================
%%% Comprehensive Array Spec Tests
%%%===================================================================

comprehensive_array_spec_tests() ->
    [
        {"extract --array= simple range", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --array=0-10\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"0-10">>, Req#batch_job_request.array_inx)
        end},

        {"extract --array= with step", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --array=0-100:10\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"0-100:10">>, Req#batch_job_request.array_inx)
        end},

        {"extract --array= with percent limit", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --array=1-50%5\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"1-50%5">>, Req#batch_job_request.array_inx)
        end},

        {"extract --array= comma-separated list", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --array=1,3,5,7\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"1,3,5,7">>, Req#batch_job_request.array_inx)
        end},

        {"extract --array= mixed range and list", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --array=1-5,10,15-20\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"1-5,10,15-20">>, Req#batch_job_request.array_inx)
        end}
    ].

%%%===================================================================
%%% Comprehensive Output Path Tests
%%%===================================================================

comprehensive_output_path_tests() ->
    [
        {"extract --output= absolute path", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --output=/home/user/output_%j.out\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"/home/user/output_%j.out">>, Req#batch_job_request.std_out)
        end},

        {"extract --error= absolute path", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --error=/home/user/error_%j.err\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"/home/user/error_%j.err">>, Req#batch_job_request.std_err)
        end},

        {"extract -o short flag", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH -o /tmp/output.out\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"/tmp/output.out">>, Req#batch_job_request.std_out)
        end},

        {"extract -e short flag", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH -e /tmp/error.err\necho hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"/tmp/error.err">>, Req#batch_job_request.std_err)
        end},

        {"extract paths with job substitutions", fun() ->
            Script = <<"#!/bin/bash\n",
                       "#SBATCH --output=/jobs/%x_%j_%a.out\n",
                       "#SBATCH --error=/jobs/%x_%j_%a.err\n",
                       "echo hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"/jobs/%x_%j_%a.out">>, Req#batch_job_request.std_out),
            ?assertEqual(<<"/jobs/%x_%j_%a.err">>, Req#batch_job_request.std_err)
        end}
    ].

%%%===================================================================
%%% Comprehensive Kill/Cancel/Signal Tests
%%%===================================================================

comprehensive_kill_cancel_signal_tests() ->
    [
        {"decode cancel job - all fields", fun() ->
            Body = <<12345:32/big, 0:32/big, 15:32/big, 1:32/big, 6:32/big, "12345", 0>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_CANCEL_JOB, Body),
            ?assertEqual(12345, Req#cancel_job_request.job_id),
            ?assertEqual(0, Req#cancel_job_request.step_id),
            ?assertEqual(15, Req#cancel_job_request.signal),
            ?assertEqual(1, Req#cancel_job_request.flags)
        end},

        {"decode cancel job - signals SIGKILL", fun() ->
            Body = <<99999:32/big, (-1):32/big-signed, 9:32/big, 0:32/big>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_CANCEL_JOB, Body),
            ?assertEqual(99999, Req#cancel_job_request.job_id),
            ?assertEqual(9, Req#cancel_job_request.signal)
        end},

        {"decode cancel job - signal SIGTERM", fun() ->
            Body = <<88888:32/big, 0:32/big, 15:32/big>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_CANCEL_JOB, Body),
            ?assertEqual(88888, Req#cancel_job_request.job_id),
            ?assertEqual(15, Req#cancel_job_request.signal)
        end},

        {"decode suspend request - suspend", fun() ->
            Body = <<12345:32/big, 1:16/big>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUSPEND, Body),
            ?assertEqual(12345, Req#suspend_request.job_id),
            ?assertEqual(true, Req#suspend_request.suspend)
        end},

        {"decode suspend request - resume", fun() ->
            Body = <<12345:32/big, 0:16/big>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUSPEND, Body),
            ?assertEqual(12345, Req#suspend_request.job_id),
            ?assertEqual(false, Req#suspend_request.suspend)
        end},

        {"decode signal job request - SIGUSR1", fun() ->
            Body = <<54321:32/big, 0:32/big-signed, 10:16/big, 0:16/big>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SIGNAL_JOB, Body),
            ?assertEqual(54321, Req#signal_job_request.job_id),
            ?assertEqual(0, Req#signal_job_request.step_id),
            ?assertEqual(10, Req#signal_job_request.signal)
        end},

        {"decode signal job request - SIGUSR2", fun() ->
            Body = <<67890:32/big, 1:32/big-signed, 12:16/big, 2:16/big>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SIGNAL_JOB, Body),
            ?assertEqual(67890, Req#signal_job_request.job_id),
            ?assertEqual(1, Req#signal_job_request.step_id),
            ?assertEqual(12, Req#signal_job_request.signal),
            ?assertEqual(2, Req#signal_job_request.flags)
        end}
    ].

%%%===================================================================
%%% Comprehensive Prolog/Epilog Tests
%%%===================================================================

comprehensive_prolog_epilog_tests() ->
    [
        {"decode complete prolog success", fun() ->
            Body = <<12345:32/big, 0:32/big-signed>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_COMPLETE_PROLOG, Body),
            ?assertEqual(12345, Req#complete_prolog_request.job_id),
            ?assertEqual(0, Req#complete_prolog_request.prolog_rc)
        end},

        {"decode complete prolog failure", fun() ->
            Body = <<12345:32/big, (-1):32/big-signed>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_COMPLETE_PROLOG, Body),
            ?assertEqual(12345, Req#complete_prolog_request.job_id),
            ?assertEqual(-1, Req#complete_prolog_request.prolog_rc)
        end},

        {"decode epilog complete success", fun() ->
            Body = <<54321:32/big, 0:32/big-signed>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?MESSAGE_EPILOG_COMPLETE, Body),
            ?assertEqual(54321, Req#epilog_complete_msg.job_id),
            ?assertEqual(0, Req#epilog_complete_msg.epilog_rc)
        end},

        {"decode epilog complete failure", fun() ->
            Body = <<54321:32/big, 1:32/big-signed>>,
            {ok, Req} = flurm_protocol_codec:decode_body(?MESSAGE_EPILOG_COMPLETE, Body),
            ?assertEqual(54321, Req#epilog_complete_msg.job_id),
            ?assertEqual(1, Req#epilog_complete_msg.epilog_rc)
        end}
    ].

%%%===================================================================
%%% Comprehensive Roundtrip Tests for All Message Types
%%%===================================================================

comprehensive_roundtrip_tests() ->
    [
        {"roundtrip REQUEST_PING", fun() ->
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_PING, #ping_request{}),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(?REQUEST_PING, Msg#slurm_msg.header#slurm_header.msg_type),
            ?assertMatch(#ping_request{}, Msg#slurm_msg.body)
        end},

        {"roundtrip REQUEST_NODE_REGISTRATION_STATUS true", fun() ->
            Req = #node_registration_request{status_only = true},
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_NODE_REGISTRATION_STATUS, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(true, (Msg#slurm_msg.body)#node_registration_request.status_only)
        end},

        {"roundtrip REQUEST_NODE_REGISTRATION_STATUS false", fun() ->
            Req = #node_registration_request{status_only = false},
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_NODE_REGISTRATION_STATUS, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(false, (Msg#slurm_msg.body)#node_registration_request.status_only)
        end},

        {"roundtrip REQUEST_JOB_INFO", fun() ->
            Req = #job_info_request{show_flags = 3, job_id = 999, user_id = 1001},
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_JOB_INFO, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            Body = Msg#slurm_msg.body,
            ?assertEqual(3, Body#job_info_request.show_flags),
            ?assertEqual(999, Body#job_info_request.job_id),
            ?assertEqual(1001, Body#job_info_request.user_id)
        end},

        {"roundtrip REQUEST_CANCEL_JOB", fun() ->
            Req = #cancel_job_request{
                job_id = 12345,
                job_id_str = <<"12345">>,
                step_id = 0,
                signal = 9,
                flags = 1
            },
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_CANCEL_JOB, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            Body = Msg#slurm_msg.body,
            ?assertEqual(12345, Body#cancel_job_request.job_id),
            ?assertEqual(9, Body#cancel_job_request.signal),
            ?assertEqual(1, Body#cancel_job_request.flags)
        end},

        {"roundtrip RESPONSE_SLURM_RC positive", fun() ->
            Resp = #slurm_rc_response{return_code = 42},
            {ok, Encoded} = flurm_protocol_codec:encode(?RESPONSE_SLURM_RC, Resp),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(42, (Msg#slurm_msg.body)#slurm_rc_response.return_code)
        end},

        {"roundtrip RESPONSE_SLURM_RC negative", fun() ->
            Resp = #slurm_rc_response{return_code = -1},
            {ok, Encoded} = flurm_protocol_codec:encode(?RESPONSE_SLURM_RC, Resp),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(-1, (Msg#slurm_msg.body)#slurm_rc_response.return_code)
        end},

        {"roundtrip RESPONSE_SLURM_RC max negative", fun() ->
            Resp = #slurm_rc_response{return_code = -2147483648},
            {ok, Encoded} = flurm_protocol_codec:encode(?RESPONSE_SLURM_RC, Resp),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(-2147483648, (Msg#slurm_msg.body)#slurm_rc_response.return_code)
        end},

        {"roundtrip RESPONSE_SLURM_RC max positive", fun() ->
            Resp = #slurm_rc_response{return_code = 2147483647},
            {ok, Encoded} = flurm_protocol_codec:encode(?RESPONSE_SLURM_RC, Resp),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(2147483647, (Msg#slurm_msg.body)#slurm_rc_response.return_code)
        end},

        {"roundtrip RESPONSE_SUBMIT_BATCH_JOB", fun() ->
            Resp = #batch_job_response{
                job_id = 99999,
                step_id = 0,
                error_code = 0,
                job_submit_user_msg = <<"Job 99999 submitted successfully">>
            },
            {ok, Encoded} = flurm_protocol_codec:encode(?RESPONSE_SUBMIT_BATCH_JOB, Resp),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            Body = Msg#slurm_msg.body,
            ?assertEqual(99999, Body#batch_job_response.job_id),
            ?assertEqual(0, Body#batch_job_response.step_id),
            ?assertEqual(0, Body#batch_job_response.error_code)
        end}
    ].

%%%===================================================================
%%% Comprehensive Error Path Tests
%%%===================================================================

comprehensive_error_path_tests() ->
    [
        {"decode empty binary returns error", fun() ->
            ?assertMatch({error, {incomplete_length_prefix, 0}},
                flurm_protocol_codec:decode(<<>>))
        end},

        {"decode 1-byte binary returns error", fun() ->
            ?assertMatch({error, {incomplete_length_prefix, 1}},
                flurm_protocol_codec:decode(<<1>>))
        end},

        {"decode 2-byte binary returns error", fun() ->
            ?assertMatch({error, {incomplete_length_prefix, 2}},
                flurm_protocol_codec:decode(<<1, 2>>))
        end},

        {"decode 3-byte binary returns error", fun() ->
            ?assertMatch({error, {incomplete_length_prefix, 3}},
                flurm_protocol_codec:decode(<<1, 2, 3>>))
        end},

        {"decode with length < min header returns error", fun() ->
            ?assertMatch({error, {invalid_message_length, 5}},
                flurm_protocol_codec:decode(<<5:32/big, 1, 2, 3, 4, 5>>))
        end},

        {"decode incomplete message returns error", fun() ->
            ?assertMatch({error, {incomplete_message, 100, _}},
                flurm_protocol_codec:decode(<<100:32/big, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10>>))
        end},

        {"decode_with_extra empty binary", fun() ->
            ?assertMatch({error, {incomplete_length_prefix, 0}},
                flurm_protocol_codec:decode_with_extra(<<>>))
        end},

        {"decode_response empty binary", fun() ->
            ?assertMatch({error, {incomplete_length_prefix, 0}},
                flurm_protocol_codec:decode_response(<<>>))
        end},

        {"decode_with_extra incomplete", fun() ->
            ?assertMatch({error, {incomplete_length_prefix, 2}},
                flurm_protocol_codec:decode_with_extra(<<1, 2>>))
        end},

        {"decode_response incomplete", fun() ->
            ?assertMatch({error, {incomplete_length_prefix, 3}},
                flurm_protocol_codec:decode_response(<<1, 2, 3>>))
        end}
    ].

%%%===================================================================
%%% Auth Section Tests - Extended
%%%===================================================================

extended_auth_section_tests() ->
    [
        {"strip_auth_section with MUNGE plugin ID", fun() ->
            %% "credential!" is 11 bytes
            Binary = <<101:32/big, 11:32/big, "credential!", "body data">>,
            {ok, Body, AuthInfo} = flurm_protocol_codec:strip_auth_section(Binary),
            ?assertEqual(<<"body data">>, Body),
            ?assertEqual(munge, maps:get(auth_type, AuthInfo)),
            ?assertEqual(101, maps:get(plugin_id, AuthInfo)),
            ?assertEqual(11, maps:get(cred_len, AuthInfo))
        end},

        {"strip_auth_section with unknown plugin ID", fun() ->
            Binary = <<999:32/big, 4:32/big, "test", "remaining body">>,
            {ok, Body, AuthInfo} = flurm_protocol_codec:strip_auth_section(Binary),
            ?assertEqual(<<"remaining body">>, Body),
            ?assertEqual(unknown, maps:get(auth_type, AuthInfo)),
            ?assertEqual(999, maps:get(plugin_id, AuthInfo))
        end},

        {"strip_auth_section too short", fun() ->
            Binary = <<1, 2, 3>>,
            ?assertMatch({error, {auth_section_too_short, 3}},
                flurm_protocol_codec:strip_auth_section(Binary))
        end},

        {"strip_auth_section exact 8 bytes (min)", fun() ->
            Binary = <<100:32/big, 0:32/big>>,  % 0 length credential
            {ok, Body, _AuthInfo} = flurm_protocol_codec:strip_auth_section(Binary),
            ?assertEqual(<<>>, Body)
        end},

        {"strip_auth_section credential longer than remaining", fun() ->
            Binary = <<100:32/big, 1000:32/big, "short">>,
            ?assertMatch({error, {auth_cred_too_short, 1000}},
                flurm_protocol_codec:strip_auth_section(Binary))
        end}
    ].

%%%===================================================================
%%% Message Type Classification Tests - Extended
%%%===================================================================

extended_message_type_tests() ->
    [
        {"message_type_name for REQUEST_NODE_REGISTRATION_STATUS", fun() ->
            ?assertEqual(request_node_registration_status,
                flurm_protocol_codec:message_type_name(?REQUEST_NODE_REGISTRATION_STATUS))
        end},

        {"message_type_name for MESSAGE_NODE_REGISTRATION_STATUS", fun() ->
            ?assertEqual(message_node_registration_status,
                flurm_protocol_codec:message_type_name(?MESSAGE_NODE_REGISTRATION_STATUS))
        end},

        {"message_type_name for REQUEST_RECONFIGURE", fun() ->
            ?assertEqual(request_reconfigure,
                flurm_protocol_codec:message_type_name(?REQUEST_RECONFIGURE))
        end},

        {"message_type_name for REQUEST_SHUTDOWN", fun() ->
            ?assertEqual(request_shutdown,
                flurm_protocol_codec:message_type_name(?REQUEST_SHUTDOWN))
        end},

        {"message_type_name for REQUEST_BUILD_INFO", fun() ->
            ?assertEqual(request_build_info,
                flurm_protocol_codec:message_type_name(?REQUEST_BUILD_INFO))
        end},

        {"message_type_name for REQUEST_NODE_INFO", fun() ->
            ?assertEqual(request_node_info,
                flurm_protocol_codec:message_type_name(?REQUEST_NODE_INFO))
        end},

        {"message_type_name for RESPONSE_NODE_INFO", fun() ->
            ?assertEqual(response_node_info,
                flurm_protocol_codec:message_type_name(?RESPONSE_NODE_INFO))
        end},

        {"message_type_name for REQUEST_PARTITION_INFO", fun() ->
            ?assertEqual(request_partition_info,
                flurm_protocol_codec:message_type_name(?REQUEST_PARTITION_INFO))
        end},

        {"message_type_name for RESPONSE_PARTITION_INFO", fun() ->
            ?assertEqual(response_partition_info,
                flurm_protocol_codec:message_type_name(?RESPONSE_PARTITION_INFO))
        end},

        {"message_type_name for REQUEST_RESOURCE_ALLOCATION", fun() ->
            ?assertEqual(request_resource_allocation,
                flurm_protocol_codec:message_type_name(?REQUEST_RESOURCE_ALLOCATION))
        end},

        {"message_type_name for RESPONSE_RESOURCE_ALLOCATION", fun() ->
            ?assertEqual(response_resource_allocation,
                flurm_protocol_codec:message_type_name(?RESPONSE_RESOURCE_ALLOCATION))
        end},

        {"message_type_name for REQUEST_KILL_JOB", fun() ->
            ?assertEqual(request_kill_job,
                flurm_protocol_codec:message_type_name(?REQUEST_KILL_JOB))
        end},

        {"message_type_name for REQUEST_UPDATE_JOB", fun() ->
            ?assertEqual(request_update_job,
                flurm_protocol_codec:message_type_name(?REQUEST_UPDATE_JOB))
        end},

        {"message_type_name for unknown type", fun() ->
            ?assertEqual({unknown, 99999},
                flurm_protocol_codec:message_type_name(99999))
        end},

        {"is_request coverage for control messages", fun() ->
            ?assert(flurm_protocol_codec:is_request(?REQUEST_RECONFIGURE)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_SHUTDOWN)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_BUILD_INFO)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_STATS_INFO))
        end},

        {"is_request coverage for step messages", fun() ->
            ?assert(flurm_protocol_codec:is_request(?REQUEST_JOB_STEP_CREATE)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_JOB_STEP_INFO)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_STEP_COMPLETE))
        end},

        {"is_request coverage for job control", fun() ->
            ?assert(flurm_protocol_codec:is_request(?REQUEST_UPDATE_JOB)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_KILL_JOB)),
            ?assert(flurm_protocol_codec:is_request(?REQUEST_LAUNCH_TASKS))
        end},

        {"is_response coverage for info responses", fun() ->
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_BUILD_INFO)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_CONFIG_INFO)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_STATS_INFO))
        end},

        {"is_response coverage for step responses", fun() ->
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_JOB_STEP_CREATE)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_JOB_STEP_INFO)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_STEP_LAYOUT))
        end},

        {"is_response coverage for rc messages", fun() ->
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_SLURM_RC)),
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_SLURM_RC_MSG))
        end}
    ].

%%%===================================================================
%%% Info Message Response Encoding Tests
%%%===================================================================

info_response_encoding_tests() ->
    [
        {"encode RESPONSE_NODE_INFO empty", fun() ->
            Resp = #node_info_response{
                last_update = erlang:system_time(second),
                node_count = 0,
                nodes = []
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_NODE_INFO, Resp),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) > 10)
        end},

        {"encode RESPONSE_NODE_INFO with one node", fun() ->
            Node = #node_info{
                name = <<"node01">>,
                node_hostname = <<"node01.cluster">>,
                node_addr = <<"192.168.1.1">>,
                port = 6818,
                node_state = 0,
                cpus = 32,
                boards = 1,
                sockets = 2,
                cores = 8,
                threads = 2,
                real_memory = 65536,
                tmp_disk = 51200,
                weight = 1,
                arch = <<"x86_64">>,
                features = <<"gpu">>,
                features_act = <<"gpu">>,
                os = <<"Linux">>,
                version = <<"22.05.0">>
            },
            Resp = #node_info_response{
                last_update = erlang:system_time(second),
                node_count = 1,
                nodes = [Node]
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_NODE_INFO, Resp),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) > 100)
        end},

        {"encode RESPONSE_PARTITION_INFO empty", fun() ->
            Resp = #partition_info_response{
                last_update = erlang:system_time(second),
                partition_count = 0,
                partitions = []
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_PARTITION_INFO, Resp),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) > 10)
        end},

        {"encode RESPONSE_PARTITION_INFO with partitions", fun() ->
            Part1 = #partition_info{
                name = <<"default">>,
                max_time = 1440,
                default_time = 60,
                max_nodes = 100,
                min_nodes = 1,
                total_nodes = 50,
                total_cpus = 1600,
                priority_job_factor = 1,
                priority_tier = 1,
                state_up = 1,
                nodes = <<"node[01-50]">>
            },
            Part2 = #partition_info{
                name = <<"gpu">>,
                max_time = 720,
                default_time = 60,
                max_nodes = 10,
                min_nodes = 1,
                total_nodes = 8,
                total_cpus = 256,
                priority_job_factor = 2,
                priority_tier = 2,
                state_up = 1,
                nodes = <<"gpu[01-08]">>
            },
            Resp = #partition_info_response{
                last_update = erlang:system_time(second),
                partition_count = 2,
                partitions = [Part1, Part2]
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_PARTITION_INFO, Resp),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) > 100)
        end},

        {"encode RESPONSE_JOB_INFO empty", fun() ->
            Resp = #job_info_response{
                last_update = erlang:system_time(second),
                job_count = 0,
                jobs = []
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_JOB_INFO, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode RESPONSE_JOB_INFO with job", fun() ->
            Job = #job_info{
                job_id = 12345,
                user_id = 1000,
                group_id = 1000,
                name = <<"test_job">>,
                partition = <<"batch">>,
                account = <<"users">>,
                job_state = 1,
                num_nodes = 1,
                num_cpus = 4,
                num_tasks = 4,
                time_limit = 3600,
                start_time = erlang:system_time(second),
                submit_time = erlang:system_time(second) - 60
            },
            Resp = #job_info_response{
                last_update = erlang:system_time(second),
                job_count = 1,
                jobs = [Job]
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_JOB_INFO, Resp),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) > 100)
        end}
    ].

%%%===================================================================
%%% SRUN Message Tests
%%%===================================================================

srun_message_tests() ->
    [
        {"encode SRUN_JOB_COMPLETE", fun() ->
            Msg = #srun_job_complete{job_id = 12345, step_id = 0},
            {ok, Binary} = flurm_protocol_codec:encode_body(?SRUN_JOB_COMPLETE, Msg),
            <<JobId:32/big, StepId:32/big, _StepHetComp:32/big>> = Binary,
            ?assertEqual(12345, JobId),
            ?assertEqual(0, StepId)
        end},

        {"encode SRUN_JOB_COMPLETE with step", fun() ->
            Msg = #srun_job_complete{job_id = 99999, step_id = 5},
            {ok, Binary} = flurm_protocol_codec:encode_body(?SRUN_JOB_COMPLETE, Msg),
            <<JobId:32/big, StepId:32/big, _:32/big>> = Binary,
            ?assertEqual(99999, JobId),
            ?assertEqual(5, StepId)
        end},

        {"encode SRUN_PING", fun() ->
            Msg = #srun_ping{},
            {ok, Binary} = flurm_protocol_codec:encode_body(?SRUN_PING, Msg),
            ?assertEqual(<<>>, Binary)
        end},

        {"encode RESPONSE_JOB_READY with map", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_JOB_READY, #{return_code => 0}),
            ?assertEqual(<<0:32/big-signed>>, Binary)
        end},

        {"encode RESPONSE_JOB_READY with integer", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_JOB_READY, 1),
            ?assertEqual(<<1:32/big-signed>>, Binary)
        end},

        {"encode RESPONSE_JOB_READY error code", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_JOB_READY, -1),
            ?assertEqual(<<(-1):32/big-signed>>, Binary)
        end}
    ].

%%%===================================================================
%%% Resource Allocation Response Tests
%%%===================================================================

resource_allocation_response_tests() ->
    [
        {"encode RESPONSE_RESOURCE_ALLOCATION minimal", fun() ->
            Resp = #resource_allocation_response{
                job_id = 12345,
                error_code = 0
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_RESOURCE_ALLOCATION, Resp),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) > 50)
        end},

        {"encode RESPONSE_RESOURCE_ALLOCATION with nodes", fun() ->
            Resp = #resource_allocation_response{
                job_id = 99999,
                node_list = <<"node01,node02">>,
                num_nodes = 2,
                partition = <<"batch">>,
                error_code = 0,
                job_submit_user_msg = <<"Allocated 2 nodes">>
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_RESOURCE_ALLOCATION, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode RESPONSE_RESOURCE_ALLOCATION with error", fun() ->
            Resp = #resource_allocation_response{
                job_id = 0,
                error_code = -1,
                job_submit_user_msg = <<"Allocation failed">>
            },
            {ok, Binary} = flurm_protocol_codec:encode(?RESPONSE_RESOURCE_ALLOCATION, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode RESPONSE_JOB_ALLOCATION_INFO same as RESPONSE_RESOURCE_ALLOCATION", fun() ->
            Resp = #resource_allocation_response{job_id = 55555, node_list = <<"node01">>},
            {ok, Bin1} = flurm_protocol_codec:encode_body(?RESPONSE_RESOURCE_ALLOCATION, Resp),
            {ok, Bin2} = flurm_protocol_codec:encode_body(?RESPONSE_JOB_ALLOCATION_INFO, Resp),
            ?assertEqual(Bin1, Bin2)
        end}
    ].

%%%===================================================================
%%% Extract Full Job Desc Tests
%%%===================================================================

extract_full_job_desc_tests() ->
    [
        {"extract_full_job_desc too small", fun() ->
            Binary = <<1, 2, 3, 4, 5>>,
            ?assertMatch({error, binary_too_small},
                flurm_protocol_codec:extract_full_job_desc(Binary))
        end},

        {"extract_full_job_desc minimal valid", fun() ->
            Binary = list_to_binary(lists:duplicate(100, 0)),
            Result = flurm_protocol_codec:extract_full_job_desc(Binary),
            ?assertMatch({ok, _}, Result),
            {ok, JobDesc} = Result,
            ?assert(is_map(JobDesc))
        end},

        {"extract_full_job_desc returns map with expected keys", fun() ->
            Binary = <<12345:32/big, 1000:32/big, 1000:32/big, 0:800/big>>,
            {ok, JobDesc} = flurm_protocol_codec:extract_full_job_desc(Binary),
            ?assert(maps:is_key(user_id, JobDesc)),
            ?assert(maps:is_key(group_id, JobDesc)),
            ?assert(maps:is_key(min_nodes, JobDesc)),
            ?assert(maps:is_key(min_cpus, JobDesc))
        end}
    ].

%%%===================================================================
%%% Response Encoding Variants Tests
%%%===================================================================

response_encoding_variants_tests() ->
    [
        {"encode_response includes auth section", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_response(
                ?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = 0}),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) > 24)
        end},

        {"encode_response_no_auth has SLURM_NO_AUTH_CRED flag", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_response_no_auth(
                ?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = 0}),
            <<_Length:32/big, _Version:16/big, Flags:16/big, _Rest/binary>> = Binary,
            ?assertEqual(?SLURM_NO_AUTH_CRED, Flags band ?SLURM_NO_AUTH_CRED)
        end},

        {"encode_response_no_auth smaller than with auth", fun() ->
            {ok, WithAuth} = flurm_protocol_codec:encode_response(
                ?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = 0}),
            {ok, NoAuth} = flurm_protocol_codec:encode_response_no_auth(
                ?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = 0}),
            ?assert(byte_size(NoAuth) < byte_size(WithAuth))
        end},

        {"encode_response_proper_auth produces valid message", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_response_proper_auth(
                ?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = 42}),
            ?assert(is_binary(Binary)),
            <<Length:32/big, Rest/binary>> = Binary,
            ?assertEqual(Length, byte_size(Rest))
        end}
    ].

%%%===================================================================
%%% Reconfigure Response Tests
%%%===================================================================

reconfigure_response_tests() ->
    [
        {"encode reconfigure_response with record", fun() ->
            Resp = #reconfigure_response{
                return_code = 0,
                message = <<"Configuration reloaded successfully">>,
                changed_keys = [max_job_count, slurmctld_timeout, scheduler_parameters],
                version = 22050
            },
            {ok, Binary} = flurm_protocol_codec:encode_reconfigure_response(Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode reconfigure_response with error code", fun() ->
            Resp = #reconfigure_response{
                return_code = -1,
                message = <<"Configuration reload failed">>,
                changed_keys = [],
                version = 22050
            },
            {ok, Binary} = flurm_protocol_codec:encode_reconfigure_response(Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode reconfigure_response with non-record", fun() ->
            Result = flurm_protocol_codec:encode_reconfigure_response(not_a_record),
            ?assertMatch({ok, _}, Result)
        end}
    ].

%%%===================================================================
%%% Job Step Request/Response Tests
%%%===================================================================

job_step_request_response_tests() ->
    [

        {"encode job step create response", fun() ->
            Resp = #job_step_create_response{
                job_step_id = 3,
                job_id = 12345,
                user_id = 1000,
                group_id = 1000,
                user_name = <<"testuser">>,
                node_list = <<"node01">>,
                num_tasks = 4,
                error_code = 0
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_JOB_STEP_CREATE, Resp),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) > 100)
        end},

        {"encode job step info response - empty", fun() ->
            Resp = #job_step_info_response{
                last_update = erlang:system_time(second),
                step_count = 0,
                steps = []
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_JOB_STEP_INFO, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode job step info response - with step", fun() ->
            Step = #job_step_info{
                job_id = 12345,
                step_id = 0,
                step_name = <<"batch">>,
                partition = <<"default">>,
                user_id = 1000,
                state = 1,
                num_tasks = 4,
                num_cpus = 4,
                time_limit = 3600,
                start_time = erlang:system_time(second),
                run_time = 60,
                nodes = <<"node01">>,
                node_cnt = 1,
                exit_code = 0
            },
            Resp = #job_step_info_response{
                last_update = erlang:system_time(second),
                step_count = 1,
                steps = [Step]
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_JOB_STEP_INFO, Resp),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) > 50)
        end}
    ].

%%%===================================================================
%%% Launch Tasks Tests
%%%===================================================================

launch_tasks_tests() ->
    [
        {"encode launch tasks response - minimal", fun() ->
            Resp = #launch_tasks_response{
                job_id = 12345,
                step_id = 0,
                step_het_comp = 0,
                return_code = 0,
                node_name = <<"node01">>,
                count_of_pids = 1,
                local_pids = [1234],
                gtids = [0]
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_LAUNCH_TASKS, Resp),
            ?assert(is_binary(Binary)),
            <<JobId:32/big, StepId:32/big, _:32/big, RC:32/signed-big, _/binary>> = Binary,
            ?assertEqual(12345, JobId),
            ?assertEqual(0, StepId),
            ?assertEqual(0, RC)
        end},

        {"encode launch tasks response - multiple pids", fun() ->
            Resp = #launch_tasks_response{
                job_id = 54321,
                step_id = 1,
                step_het_comp = 0,
                return_code = 0,
                node_name = <<"compute01">>,
                count_of_pids = 4,
                local_pids = [1001, 1002, 1003, 1004],
                gtids = [0, 1, 2, 3]
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_LAUNCH_TASKS, Resp),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) > 50)
        end},

        {"encode launch tasks response - error code", fun() ->
            Resp = #launch_tasks_response{
                job_id = 99999,
                step_id = 0,
                return_code = -1,
                node_name = <<"node01">>,
                count_of_pids = 0,
                local_pids = [],
                gtids = []
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_LAUNCH_TASKS, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode launch tasks response - map format", fun() ->
            Map = #{
                job_id => 12345,
                step_id => 0,
                return_code => 0,
                node_name => <<"node01">>,
                local_pids => [5555],
                gtids => [0]
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_LAUNCH_TASKS, Map),
            ?assert(is_binary(Binary))
        end},

        {"encode task exit message - single task", fun() ->
            Map = #{
                job_id => 12345,
                step_id => 0,
                task_ids => [0],
                return_codes => [0]
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?MESSAGE_TASK_EXIT, Map),
            ?assert(is_binary(Binary)),
            <<RC:32/signed-big, NumTasks:32/big, _/binary>> = Binary,
            ?assertEqual(0, RC),
            ?assertEqual(1, NumTasks)
        end},

        {"encode task exit message - multiple tasks", fun() ->
            Map = #{
                job_id => 54321,
                step_id => 1,
                task_ids => [0, 1, 2, 3],
                return_codes => [0, 0, 1, 0]
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?MESSAGE_TASK_EXIT, Map),
            ?assert(is_binary(Binary))
        end},

        {"encode task exit message - error return code", fun() ->
            Map = #{
                job_id => 99999,
                step_id => 0,
                task_ids => [0],
                return_codes => [-15]
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?MESSAGE_TASK_EXIT, Map),
            ?assert(is_binary(Binary)),
            <<RC:32/signed-big, _/binary>> = Binary,
            ?assertEqual(-15, RC)
        end},

        {"encode reattach tasks response - minimal", fun() ->
            Resp = #reattach_tasks_response{
                return_code = 0,
                node_name = <<"node01">>,
                count_of_pids = 0,
                local_pids = [],
                gtids = [],
                executable_names = []
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_REATTACH_TASKS, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode reattach tasks response - with tasks", fun() ->
            Resp = #reattach_tasks_response{
                return_code = 0,
                node_name = <<"compute01">>,
                count_of_pids = 2,
                local_pids = [1001, 1002],
                gtids = [0, 1],
                executable_names = [<<"/bin/bash">>, <<"/bin/bash">>]
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_REATTACH_TASKS, Resp),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) > 30)
        end},

        {"encode reattach tasks response - map format", fun() ->
            Map = #{
                return_code => 0,
                node_name => <<"node01">>,
                local_pids => [9999],
                gtids => [0],
                executable_names => [<<"/usr/bin/python">>]
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_REATTACH_TASKS, Map),
            ?assert(is_binary(Binary))
        end}
    ].

%%%===================================================================
%%% Info/Query Request Decoders Tests
%%%===================================================================

info_query_request_tests() ->
    [
        {"encode node info request", fun() ->
            Req = #node_info_request{show_flags = 16#FF},
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_NODE_INFO, Req),
            ?assert(is_binary(Encoded)),
            ?assert(byte_size(Encoded) > 10)
        end},

        {"encode partition info request", fun() ->
            Req = #partition_info_request{show_flags = 3},
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_PARTITION_INFO, Req),
            ?assert(is_binary(Encoded)),
            ?assert(byte_size(Encoded) > 10)
        end},

        {"encode and decode job info roundtrip", fun() ->
            Req = #job_info_request{show_flags = 1, job_id = 12345},
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_JOB_INFO, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            Body = Msg#slurm_msg.body,
            ?assertEqual(1, Body#job_info_request.show_flags),
            ?assertEqual(12345, Body#job_info_request.job_id)
        end}
    ].

%%%===================================================================
%%% Info/Query Response Encoders Tests
%%%===================================================================

info_query_response_tests() ->
    [
        {"encode reservation info response - empty", fun() ->
            Resp = #reservation_info_response{
                last_update = erlang:system_time(second),
                reservation_count = 0,
                reservations = []
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_RESERVATION_INFO, Resp),
            ?assert(is_binary(Binary)),
            <<Count:32/big, _/binary>> = Binary,
            ?assertEqual(0, Count)
        end},

        {"encode reservation info response - with reservation", fun() ->
            Resv = #reservation_info{
                name = <<"maint">>,
                node_list = <<"node[01-10]">>,
                node_cnt = 10,
                start_time = erlang:system_time(second),
                end_time = erlang:system_time(second) + 3600,
                users = <<"admin">>,
                accounts = <<"system">>
            },
            Resp = #reservation_info_response{
                last_update = erlang:system_time(second),
                reservation_count = 1,
                reservations = [Resv]
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_RESERVATION_INFO, Resp),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) > 50)
        end},

        {"encode license info response - empty", fun() ->
            Resp = #license_info_response{
                last_update = erlang:system_time(second),
                license_count = 0,
                licenses = []
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_LICENSE_INFO, Resp),
            ?assert(is_binary(Binary))
        end},

        {"encode license info response - with license", fun() ->
            Lic = #license_info{
                name = <<"matlab">>,
                total = 10,
                in_use = 5,
                available = 5,
                reserved = 0,
                remote = 0
            },
            Resp = #license_info_response{
                last_update = erlang:system_time(second),
                license_count = 1,
                licenses = [Lic]
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_LICENSE_INFO, Resp),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) > 20)
        end},

        {"encode topo info response - empty", fun() ->
            Resp = #topo_info_response{
                topo_count = 0,
                topos = []
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_TOPO_INFO, Resp),
            ?assert(is_binary(Binary)),
            <<Count:32/big>> = Binary,
            ?assertEqual(0, Count)
        end}
    ].

%%%===================================================================
%%% Job Control Tests
%%%===================================================================

job_control_tests() ->
    [
        {"encode job will run response", fun() ->
            Resp = #job_will_run_response{
                job_id = 12345,
                start_time = erlang:system_time(second) + 60,
                node_list = <<"node[01-04]">>,
                proc_cnt = 32,
                error_code = 0
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_JOB_WILL_RUN, Resp),
            ?assert(is_binary(Binary)),
            <<JobId:32/big, _/binary>> = Binary,
            ?assertEqual(12345, JobId)
        end},

        {"encode cancel job roundtrip", fun() ->
            Req = #cancel_job_request{
                job_id = 99999,
                job_id_str = <<"99999">>,
                signal = 9,
                flags = 0
            },
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_CANCEL_JOB, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            Body = Msg#slurm_msg.body,
            ?assertEqual(99999, Body#cancel_job_request.job_id),
            ?assertEqual(9, Body#cancel_job_request.signal)
        end}
    ].

%%%===================================================================
%%% Complete Prolog/Epilog Tests
%%%===================================================================

complete_prolog_epilog_tests() ->
    [
        {"encode prolog response", fun() ->
            Resp = #slurm_rc_response{return_code = 0},
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_SLURM_RC, Resp),
            ?assert(is_binary(Binary)),
            <<RC:32/signed-big>> = Binary,
            ?assertEqual(0, RC)
        end},

        {"encode prolog response error", fun() ->
            Resp = #slurm_rc_response{return_code = -1},
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_SLURM_RC, Resp),
            <<RC:32/signed-big>> = Binary,
            ?assertEqual(-1, RC)
        end}
    ].

%%%===================================================================
%%% Header Encoding/Decoding Tests
%%%===================================================================

header_encoding_decoding_tests() ->
    [
        {"encode creates valid header", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_PING, #ping_request{}),
            <<_Length:32/big, Version:16/big, _Flags:16/big, _/binary>> = Binary,
            ?assertEqual(?SLURM_PROTOCOL_VERSION, Version)
        end},

        {"encode creates binary with length prefix", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_PING, #ping_request{}),
            <<Length:32/big, Rest/binary>> = Binary,
            ?assertEqual(Length, byte_size(Rest))
        end},

        {"response header includes SLURM_NO_AUTH_CRED flag", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_response_no_auth(?RESPONSE_SLURM_RC,
                #slurm_rc_response{return_code = 0}),
            <<_Length:32/big, _Version:16/big, Flags:16/big, _/binary>> = Binary,
            ?assertEqual(?SLURM_NO_AUTH_CRED, Flags band ?SLURM_NO_AUTH_CRED)
        end}
    ].

%%%===================================================================
%%% Binary Encoding Helpers Tests
%%%===================================================================

binary_encoding_helpers_tests() ->
    [
        {"encode produces valid binary", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_PING, #ping_request{}),
            ?assert(is_binary(Binary))
        end},

        {"encode_body produces body binary", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(?REQUEST_PING, #ping_request{}),
            ?assert(is_binary(Binary))
        end},

        {"encode handles record types", fun() ->
            {ok, _} = flurm_protocol_codec:encode(?REQUEST_PING, #ping_request{}),
            {ok, _} = flurm_protocol_codec:encode(?RESPONSE_SLURM_RC, #slurm_rc_response{return_code = 0})
        end}
    ].

%%%===================================================================
%%% Protocol Version Tests
%%%===================================================================

protocol_version_tests() ->
    [
        {"default protocol version is SLURM 22.05", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_PING, #ping_request{}),
            <<_Length:32/big, Version:16/big, _/binary>> = Binary,
            ?assertEqual(?SLURM_PROTOCOL_VERSION, Version)
        end},

        {"message includes correct version in header", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode(?REQUEST_NODE_REGISTRATION_STATUS,
                #node_registration_request{status_only = true}),
            <<_Length:32/big, Version:16/big, _/binary>> = Binary,
            ?assertEqual(?SLURM_PROTOCOL_VERSION, Version)
        end},

        {"response includes correct version", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_response(?RESPONSE_SLURM_RC,
                #slurm_rc_response{return_code = 0}),
            <<_Length:32/big, Version:16/big, _/binary>> = Binary,
            ?assertEqual(?SLURM_PROTOCOL_VERSION, Version)
        end}
    ].

%%%===================================================================
%%% Message Structure Tests
%%%===================================================================

message_structure_tests() ->
    [
        {"decode returns slurm_msg record", fun() ->
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_PING, #ping_request{}),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assert(is_record(Msg, slurm_msg)),
            ?assert(is_record(Msg#slurm_msg.header, slurm_header)),
            ?assertMatch(#ping_request{}, Msg#slurm_msg.body)
        end},

        {"decode response returns slurm_msg", fun() ->
            {ok, Encoded} = flurm_protocol_codec:encode_response(?RESPONSE_SLURM_RC,
                #slurm_rc_response{return_code = 0}),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode_response(Encoded),
            ?assert(is_record(Msg, slurm_msg)),
            ?assertEqual(?RESPONSE_SLURM_RC, Msg#slurm_msg.header#slurm_header.msg_type)
        end}
    ].

%%%===================================================================
%%% Helper Functions for Tests
%%%===================================================================

build_batch_job_binary(Script) ->
    %% Build a minimal batch job request binary with the given script
    %% The scanner looks for #!/ pattern to find the script
    Padding = list_to_binary(lists:duplicate(100, 0)),
    ScriptLen = byte_size(Script),
    <<Padding/binary, ScriptLen:32/big, Script/binary, 0, 0, 0>>.

build_batch_job_binary_with_env(Script, EnvPart) ->
    %% Build a batch job request binary with environment variable
    Padding = list_to_binary(lists:duplicate(50, 0)),
    ScriptLen = byte_size(Script),
    <<Padding/binary, EnvPart/binary, Padding/binary, ScriptLen:32/big, Script/binary, 0, 0, 0>>.

parse_message_type_name_pairs() ->
    {ok, Bin} = file:read_file(?CODEC_SRC),
    Lines = binary:split(Bin, <<"\n">>, [global]),
    lists:reverse(lists:foldl(
      fun(Line, Acc) ->
          case re:run(Line,
                      <<"^message_type_name\\(\\?([A-Z0-9_]+)\\) -> ([a-z0-9_]+);$">>,
                      [{capture, all_but_first, binary}]) of
              {match, [MacroBin, AtomBin]} ->
                  [{binary_to_atom(MacroBin, utf8), binary_to_atom(AtomBin, utf8)} | Acc];
              nomatch ->
                  Acc
          end
      end, [], Lines)).

parse_true_macro_clauses(FunName) ->
    {ok, Bin} = file:read_file(?CODEC_SRC),
    Lines = binary:split(Bin, <<"\n">>, [global]),
    Pattern = iolist_to_binary([
        "^", FunName, "\\(\\?([A-Z0-9_]+)\\) -> true;$"
    ]),
    lists:reverse(lists:foldl(
      fun(Line, Acc) ->
          case re:run(Line, Pattern, [{capture, all_but_first, binary}]) of
              {match, [MacroBin]} -> [binary_to_atom(MacroBin, utf8) | Acc];
              nomatch -> Acc
          end
      end, [], Lines)).

parse_decode_body_macros() ->
    {ok, Bin} = file:read_file(?CODEC_SRC),
    Lines = binary:split(Bin, <<"\n">>, [global]),
    lists:reverse(lists:foldl(
      fun(Line, Acc) ->
          case re:run(Line,
                      <<"^decode_body\\(\\?([A-Z0-9_]+),\\s*[A-Za-z_][A-Za-z0-9_]*\\) ->$">>,
                      [{capture, all_but_first, binary}]) of
              {match, [MacroBin]} -> [binary_to_atom(MacroBin, utf8) | Acc];
              nomatch -> Acc
          end
      end, [], Lines)).

parse_encode_body_variable_macros() ->
    {ok, Bin} = file:read_file(?CODEC_SRC),
    Lines = binary:split(Bin, <<"\n">>, [global]),
    lists:reverse(lists:foldl(
      fun(Line, Acc) ->
          case re:run(Line,
                      <<"^encode_body\\(\\?([A-Z0-9_]+),\\s*[A-Za-z_][A-Za-z0-9_]*\\) ->$">>,
                      [{capture, all_but_first, binary}]) of
              {match, [MacroBin]} -> [binary_to_atom(MacroBin, utf8) | Acc];
              nomatch -> Acc
          end
      end, [], Lines)).

parse_macro_values() ->
    {ok, Bin} = file:read_file(?PROTOCOL_HRL),
    Lines = binary:split(Bin, <<"\n">>, [global]),
    lists:foldl(
      fun(Line, Acc) ->
          case re:run(Line,
                      <<"^-define\\(([A-Z0-9_]+),\\s*([0-9]+)\\).*$">>,
                      [{capture, all_but_first, binary}]) of
              {match, [MacroBin, ValueBin]} ->
                  Macro = binary_to_atom(MacroBin, utf8),
                  Value = binary_to_integer(ValueBin),
                  Acc#{Macro => Value};
              nomatch ->
                  Acc
          end
      end, #{}, Lines).

%%%===================================================================
%%% Additional Comprehensive Tests
%%%===================================================================

%% More SBATCH directive tests - simplified
additional_sbatch_directive_tests() ->
    [
        {"parse --mail-user directive", fun() ->
            Script = <<"#!/bin/bash\n#SBATCH --mail-user=user@example.com\necho hello">>,
            {ok, _Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script))
        end},

        {"parse multiple directives - job-name, nodes, ntasks", fun() ->
            Script = <<"#!/bin/bash\n",
                       "#SBATCH --job-name=multi_test\n",
                       "#SBATCH --nodes=4\n",
                       "#SBATCH --ntasks=16\n",
                       "echo hello">>,
            {ok, Req} = flurm_protocol_codec:decode_body(?REQUEST_SUBMIT_BATCH_JOB,
                build_batch_job_binary(Script)),
            ?assertEqual(<<"multi_test">>, Req#batch_job_request.name),
            ?assertEqual(4, Req#batch_job_request.min_nodes),
            ?assertEqual(16, Req#batch_job_request.num_tasks)
        end}
    ].

%% More encode body tests
additional_encode_body_tests() ->
    [
        {"encode body for ping request", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(?REQUEST_PING, #ping_request{}),
            ?assertEqual(<<>>, Binary)
        end},

        {"encode body for rc response - zero", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_SLURM_RC,
                #slurm_rc_response{return_code = 0}),
            ?assertEqual(<<0:32/signed-big>>, Binary)
        end},

        {"encode body for rc response - positive", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_SLURM_RC,
                #slurm_rc_response{return_code = 42}),
            ?assertEqual(<<42:32/signed-big>>, Binary)
        end},

        {"encode body for rc response - negative", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_SLURM_RC,
                #slurm_rc_response{return_code = -1}),
            ?assertEqual(<<(-1):32/signed-big>>, Binary)
        end},

        {"encode body for rc response - ESLURM codes", fun() ->
            %% Test various SLURM error codes
            lists:foreach(fun(Code) ->
                {ok, Binary} = flurm_protocol_codec:encode_body(?RESPONSE_SLURM_RC,
                    #slurm_rc_response{return_code = Code}),
                <<DecodedCode:32/signed-big>> = Binary,
                ?assertEqual(Code, DecodedCode)
            end, [-1, -2, -1000, -2000, -3000])
        end},

        {"encode body for node registration request - status only true", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(?REQUEST_NODE_REGISTRATION_STATUS,
                #node_registration_request{status_only = true}),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) > 0)
        end},

        {"encode body for node registration request - status only false", fun() ->
            {ok, Binary} = flurm_protocol_codec:encode_body(?REQUEST_NODE_REGISTRATION_STATUS,
                #node_registration_request{status_only = false}),
            ?assert(is_binary(Binary))
        end},

        {"encode body for cancel job request", fun() ->
            Req = #cancel_job_request{
                job_id = 12345,
                job_id_str = <<"12345">>,
                step_id = 0,
                signal = 9,
                flags = 1
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?REQUEST_CANCEL_JOB, Req),
            ?assert(is_binary(Binary)),
            ?assert(byte_size(Binary) >= 12)
        end},

        {"encode body for kill job request", fun() ->
            Req = #kill_job_request{
                job_id = 54321,
                job_id_str = <<"54321">>,
                signal = 15,
                flags = 0
            },
            {ok, Binary} = flurm_protocol_codec:encode_body(?REQUEST_KILL_JOB, Req),
            ?assert(is_binary(Binary))
        end}
    ].

%% More roundtrip tests
additional_roundtrip_tests() ->
    [
        {"roundtrip job info request - basic", fun() ->
            Req = #job_info_request{show_flags = 3, job_id = 12345, user_id = 1000},
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_JOB_INFO, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            Body = Msg#slurm_msg.body,
            ?assertEqual(3, Body#job_info_request.show_flags),
            ?assertEqual(12345, Body#job_info_request.job_id),
            ?assertEqual(1000, Body#job_info_request.user_id)
        end},

        {"roundtrip job info request - all zeros", fun() ->
            Req = #job_info_request{show_flags = 0, job_id = 0, user_id = 0},
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_JOB_INFO, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            Body = Msg#slurm_msg.body,
            ?assertEqual(0, Body#job_info_request.show_flags),
            ?assertEqual(0, Body#job_info_request.job_id)
        end},

        {"roundtrip job info request - max values", fun() ->
            Req = #job_info_request{show_flags = 16#FFFFFFFF, job_id = 16#FFFFFFFF, user_id = 16#FFFFFFFF},
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_JOB_INFO, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            Body = Msg#slurm_msg.body,
            ?assertEqual(16#FFFFFFFF, Body#job_info_request.show_flags)
        end},

        {"roundtrip cancel job request", fun() ->
            Req = #cancel_job_request{job_id = 99999, job_id_str = <<"99999">>, signal = 9, flags = 0},
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_CANCEL_JOB, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            Body = Msg#slurm_msg.body,
            ?assertEqual(99999, Body#cancel_job_request.job_id),
            ?assertEqual(9, Body#cancel_job_request.signal)
        end}
    ].

%% More error handling tests
additional_error_handling_tests() ->
    [
        {"decode with various short lengths", fun() ->
            lists:foreach(fun(N) ->
                Binary = list_to_binary(lists:duplicate(N, 0)),
                Result = flurm_protocol_codec:decode(Binary),
                ?assertMatch({error, _}, Result)
            end, [0, 1, 2, 3])
        end},

        {"decode with length mismatch", fun() ->
            %% Length says 100 bytes but only have 10
            Binary = <<100:32/big, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10>>,
            Result = flurm_protocol_codec:decode(Binary),
            ?assertMatch({error, {incomplete_message, 100, _}}, Result)
        end},

        {"decode with very large length", fun() ->
            Binary = <<16#FFFFFFFF:32/big, 1, 2, 3, 4>>,
            Result = flurm_protocol_codec:decode(Binary),
            ?assertMatch({error, {incomplete_message, _, _}}, Result)
        end},

        {"decode_response with short binary", fun() ->
            lists:foreach(fun(N) ->
                Binary = list_to_binary(lists:duplicate(N, 0)),
                Result = flurm_protocol_codec:decode_response(Binary),
                ?assertMatch({error, _}, Result)
            end, [0, 1, 2, 3])
        end},

        {"strip_auth_section with various sizes", fun() ->
            %% Test with exact 8 bytes (minimum for plugin_id + cred_len)
            Binary8 = <<100:32/big, 0:32/big>>,
            {ok, _, _} = flurm_protocol_codec:strip_auth_section(Binary8),

            %% Test with plugin_id but no cred_len
            Binary4 = <<100:32/big>>,
            Result4 = flurm_protocol_codec:strip_auth_section(Binary4),
            ?assertMatch({error, {auth_section_too_short, 4}}, Result4),

            %% Test empty
            Result0 = flurm_protocol_codec:strip_auth_section(<<>>),
            ?assertMatch({error, {auth_section_too_short, 0}}, Result0)
        end}
    ].

%% Message type tests - simplified
additional_message_type_tests() ->
    [
        {"message_type_name for ping", fun() ->
            ?assertEqual(request_ping, flurm_protocol_codec:message_type_name(?REQUEST_PING))
        end},

        {"message_type_name for rc response", fun() ->
            ?assertEqual(response_slurm_rc, flurm_protocol_codec:message_type_name(?RESPONSE_SLURM_RC))
        end},

        {"message_type_name for batch job request", fun() ->
            ?assertEqual(request_submit_batch_job, flurm_protocol_codec:message_type_name(?REQUEST_SUBMIT_BATCH_JOB))
        end},

        {"message_type_name for unknown returns tuple", fun() ->
            Result = flurm_protocol_codec:message_type_name(99999),
            ?assertMatch({unknown, 99999}, Result)
        end},

        {"is_response for RESPONSE_SLURM_RC", fun() ->
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_SLURM_RC))
        end},

        {"is_response for RESPONSE_JOB_INFO", fun() ->
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_JOB_INFO))
        end}
    ].

%%%===================================================================
%%% Federation Message Tests - Comprehensive
%%%===================================================================

federation_encode_decode_tests() ->
    [
        {"encode fed_info_request with show_flags", fun() ->
            Req = #fed_info_request{show_flags = 16#FF},
            Body = flurm_protocol_codec:encode_fed_info_request(Req),
            ?assert(is_binary(Body)),
            ?assertEqual(4, byte_size(Body))
        end},

        {"encode fed_info_request with zero flags", fun() ->
            Req = #fed_info_request{show_flags = 0},
            Body = flurm_protocol_codec:encode_fed_info_request(Req),
            ?assertEqual(<<0:32/big>>, Body)
        end},

        {"decode fed_info_request empty", fun() ->
            Result = flurm_protocol_codec:decode_body(?REQUEST_FED_INFO, <<>>),
            ?assertMatch({ok, #fed_info_request{}}, Result)
        end},

        {"decode fed_info_request with flags", fun() ->
            Binary = <<16#DEADBEEF:32/big, 0, 0, 0, 0>>,
            Result = flurm_protocol_codec:decode_body(?REQUEST_FED_INFO, Binary),
            ?assertMatch({ok, #fed_info_request{show_flags = 16#DEADBEEF}}, Result)
        end},

        {"encode fed_info_response empty", fun() ->
            Resp = #fed_info_response{clusters = []},
            Body = flurm_protocol_codec:encode_fed_info_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode federation_submit_request", fun() ->
            Req = #federation_submit_request{
                cluster_name = <<"cluster1">>,
                user_id = 1000,
                group_id = 1000,
                job_script = <<"#!/bin/bash\necho hello">>
            },
            Body = flurm_protocol_codec:encode_federation_submit_request(Req),
            ?assert(is_binary(Body))
        end},

        {"encode federation_submit_response", fun() ->
            Resp = #federation_submit_response{
                job_id = 12345,
                return_code = 0
            },
            Body = flurm_protocol_codec:encode_federation_submit_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode federation_job_status_request", fun() ->
            Req = #federation_job_status_request{
                job_id = 99999,
                cluster_name = <<"test_cluster">>
            },
            Body = flurm_protocol_codec:encode_federation_job_status_request(Req),
            ?assert(is_binary(Body))
        end},

        {"encode federation_job_status_response", fun() ->
            Resp = #federation_job_status_response{
                job_id = 99999,
                job_state = 1,
                return_code = 0
            },
            Body = flurm_protocol_codec:encode_federation_job_status_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode federation_job_cancel_request", fun() ->
            Req = #federation_job_cancel_request{
                job_id = 88888,
                signal = 9,
                cluster_name = <<"cancel_cluster">>
            },
            Body = flurm_protocol_codec:encode_federation_job_cancel_request(Req),
            ?assert(is_binary(Body))
        end},

        {"encode federation_job_cancel_response", fun() ->
            Resp = #federation_job_cancel_response{
                return_code = 0
            },
            Body = flurm_protocol_codec:encode_federation_job_cancel_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode update_federation_request", fun() ->
            Req = #update_federation_request{
                name = <<"my_federation">>,
                flags = 16#01,
                settings = []
            },
            Body = flurm_protocol_codec:encode_update_federation_request(Req),
            ?assert(is_binary(Body))
        end},

        {"encode update_federation_response", fun() ->
            Resp = #update_federation_response{
                return_code = 0
            },
            Body = flurm_protocol_codec:encode_update_federation_response(Resp),
            ?assert(is_binary(Body))
        end}
    ].

%%%===================================================================
%%% Federation Inter-cluster Message Tests
%%%===================================================================

federation_inter_cluster_tests() ->
    [
        {"encode fed_job_submit_msg", fun() ->
            Msg = #fed_job_submit_msg{
                cluster_name = <<"source_cluster">>,
                job_id = 111,
                user_id = 500
            },
            Body = flurm_protocol_codec:encode_fed_job_submit_msg(Msg),
            ?assert(is_binary(Body))
        end},

        {"encode fed_job_started_msg", fun() ->
            Msg = #fed_job_started_msg{
                cluster_name = <<"started_cluster">>,
                job_id = 222,
                start_time = 1234567890
            },
            Body = flurm_protocol_codec:encode_fed_job_started_msg(Msg),
            ?assert(is_binary(Body))
        end},

        {"encode fed_sibling_revoke_msg", fun() ->
            Msg = #fed_sibling_revoke_msg{
                cluster_name = <<"revoke_cluster">>,
                job_id = 333
            },
            Body = flurm_protocol_codec:encode_fed_sibling_revoke_msg(Msg),
            ?assert(is_binary(Body))
        end},

        {"encode fed_job_completed_msg", fun() ->
            Msg = #fed_job_completed_msg{
                cluster_name = <<"completed_cluster">>,
                job_id = 444,
                exit_code = 0,
                end_time = 1234567899
            },
            Body = flurm_protocol_codec:encode_fed_job_completed_msg(Msg),
            ?assert(is_binary(Body))
        end},

        {"encode fed_job_failed_msg", fun() ->
            Msg = #fed_job_failed_msg{
                cluster_name = <<"failed_cluster">>,
                job_id = 555,
                exit_code = 1,
                reason = <<"Out of memory">>
            },
            Body = flurm_protocol_codec:encode_fed_job_failed_msg(Msg),
            ?assert(is_binary(Body))
        end},

        {"decode fed_job_submit_msg", fun() ->
            %% Create a minimal valid binary for fed_job_submit_msg
            ClusterName = <<"test">>,
            ClusterLen = byte_size(ClusterName),
            Binary = <<ClusterLen:32/big, ClusterName/binary,
                       100:32/big,  % job_id
                       1000:32/big, % user_id
                       0:32/big,    % group_id
                       0:32/big,    % extra fields
                       0:32/big,
                       0:32/big,
                       0:32/big,
                       0:32/big,
                       0:32/big,
                       0:32/big,
                       0:32/big,
                       0:32/big,
                       0:32/big,
                       0:32/big,
                       0:32/big,
                       0:32/big,
                       0:32/big,
                       0:32/big,
                       0:32/big>>,
            Result = flurm_protocol_codec:decode_body(?MSG_FED_JOB_SUBMIT, Binary),
            ?assertMatch({ok, _}, Result)
        end},

        {"decode fed_job_started_msg", fun() ->
            ClusterName = <<"cluster1">>,
            ClusterLen = byte_size(ClusterName),
            Binary = <<ClusterLen:32/big, ClusterName/binary,
                       200:32/big,       % job_id
                       1234567890:64/big, % start_time
                       0:32/big, 0:32/big, 0:32/big, 0:32/big, 0:32/big>>,
            Result = flurm_protocol_codec:decode_body(?MSG_FED_JOB_STARTED, Binary),
            ?assertMatch({ok, _}, Result)
        end},

        {"decode fed_sibling_revoke_msg", fun() ->
            ClusterName = <<"revoke">>,
            ClusterLen = byte_size(ClusterName),
            Binary = <<ClusterLen:32/big, ClusterName/binary,
                       300:32/big, 0:32/big, 0:32/big, 0:32/big>>,
            Result = flurm_protocol_codec:decode_body(?MSG_FED_SIBLING_REVOKE, Binary),
            ?assertMatch({ok, _}, Result)
        end},

        {"decode fed_job_completed_msg", fun() ->
            ClusterName = <<"done">>,
            ClusterLen = byte_size(ClusterName),
            Binary = <<ClusterLen:32/big, ClusterName/binary,
                       400:32/big,        % job_id
                       0:32/big,          % exit_code (signed)
                       1234567899:64/big, % end_time
                       0:32/big, 0:32/big, 0:32/big, 0:32/big>>,
            Result = flurm_protocol_codec:decode_body(?MSG_FED_JOB_COMPLETED, Binary),
            ?assertMatch({ok, _}, Result)
        end},

        {"decode fed_job_failed_msg", fun() ->
            ClusterName = <<"fail">>,
            ClusterLen = byte_size(ClusterName),
            Reason = <<"error">>,
            ReasonLen = byte_size(Reason),
            Binary = <<ClusterLen:32/big, ClusterName/binary,
                       500:32/big,        % job_id
                       1:32/big,          % exit_code (signed)
                       ReasonLen:32/big, Reason/binary,
                       0:32/big, 0:32/big, 0:32/big, 0:32/big>>,
            Result = flurm_protocol_codec:decode_body(?MSG_FED_JOB_FAILED, Binary),
            ?assertMatch({ok, _}, Result)
        end}
    ].

%%%===================================================================
%%% Information Response Encoding Tests - Comprehensive
%%%===================================================================

info_response_encoding_comprehensive_tests() ->
    [
        {"encode reservation_info_response empty", fun() ->
            Resp = #reservation_info_response{
                last_update = 1234567890,
                reservations = []
            },
            Body = flurm_protocol_codec:encode_reservation_info_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode reservation_info_response with data", fun() ->
            Resv = #reservation_info{
                name = <<"test_resv">>,
                node_list = <<"node[01-10]">>,
                start_time = 1234567890,
                end_time = 1234577890,
                users = <<"user1,user2">>,
                accounts = <<"account1">>,
                flags = 0
            },
            Resp = #reservation_info_response{
                last_update = 1234567890,
                reservations = [Resv]
            },
            Body = flurm_protocol_codec:encode_reservation_info_response(Resp),
            ?assert(is_binary(Body)),
            ?assert(byte_size(Body) > 20)
        end},

        {"encode license_info_response empty", fun() ->
            Resp = #license_info_response{
                last_update = 1234567890,
                licenses = []
            },
            Body = flurm_protocol_codec:encode_license_info_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode license_info_response with data", fun() ->
            Lic = #license_info{
                name = <<"matlab">>,
                total = 100,
                in_use = 50,
                available = 50,
                remote = 0
            },
            Resp = #license_info_response{
                last_update = 1234567890,
                licenses = [Lic]
            },
            Body = flurm_protocol_codec:encode_license_info_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode topo_info_response empty", fun() ->
            Resp = #topo_info_response{
                last_update = 1234567890,
                topo_records = []
            },
            Body = flurm_protocol_codec:encode_topo_info_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode topo_info_response with data", fun() ->
            Topo = #topo_info{
                level = 0,
                link_speed = 10000,
                name = <<"switch0">>,
                nodes = <<"node[01-04]">>,
                switches = <<>>
            },
            Resp = #topo_info_response{
                last_update = 1234567890,
                topo_records = [Topo]
            },
            Body = flurm_protocol_codec:encode_topo_info_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode front_end_info_response empty", fun() ->
            Resp = #front_end_info_response{
                last_update = 1234567890,
                front_end_records = []
            },
            Body = flurm_protocol_codec:encode_front_end_info_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode front_end_info_response with data", fun() ->
            FE = #front_end_info{
                name = <<"frontend1">>,
                state = 1,
                boot_time = 1234560000,
                slurmd_start_time = 1234560100,
                reason = <<>>,
                reason_time = 0,
                reason_uid = 0,
                version = <<"22.05.0">>
            },
            Resp = #front_end_info_response{
                last_update = 1234567890,
                front_end_records = [FE]
            },
            Body = flurm_protocol_codec:encode_front_end_info_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode burst_buffer_info_response empty", fun() ->
            Resp = #burst_buffer_info_response{
                last_update = 1234567890,
                burst_buffers = []
            },
            Body = flurm_protocol_codec:encode_burst_buffer_info_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode burst_buffer_info_response with data", fun() ->
            Pool = #burst_buffer_pool{
                name = <<"default">>,
                total_space = 1000000000,
                granularity = 1024,
                unfree_space = 500000000
            },
            BB = #burst_buffer_info{
                name = <<"datawarp">>,
                default_pool = <<"default">>,
                total_space = 1000000000,
                used_space = 500000000,
                allow_users = <<"*">>,
                create_buffer = <<"#DW">>,
                destroy_buffer = <<"#DW destroy">>,
                get_sys_state = <<"#DW state">>,
                get_sys_status = <<"#DW status">>,
                start_stage_in = <<"#DW stage_in">>,
                start_stage_out = <<"#DW stage_out">>,
                stop_stage_in = <<"#DW stop_in">>,
                stop_stage_out = <<"#DW stop_out">>,
                pools = [Pool]
            },
            Resp = #burst_buffer_info_response{
                last_update = 1234567890,
                burst_buffers = [BB]
            },
            Body = flurm_protocol_codec:encode_burst_buffer_info_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode build_info_response", fun() ->
            Resp = #build_info_response{
                last_update = 1234567890,
                cluster_name = <<"my_cluster">>,
                control_machine = <<"slurmctld">>,
                backup_controller = <<>>,
                slurm_user_name = <<"slurm">>,
                slurm_user_id = 999,
                slurmctld_port = 6817,
                slurmd_port = 6818,
                accounting_storage_type = <<"accounting_storage/slurmdbd">>,
                accounting_storage_host = <<"slurmdbd">>,
                accounting_storage_backup_host = <<>>,
                accounting_storage_user = <<"slurm">>,
                authtype = <<"auth/munge">>,
                batch_start_timeout = 10,
                boot_time = 1234560000,
                core_spec_plugin = <<>>,
                cpu_freq_def = 0,
                cpu_freq_governors = 0,
                cred_type = <<"cred/munge">>,
                debug_flags = 0,
                enforce_part_limits = 0,
                epilog = <<>>,
                epilog_msg_time = 2000,
                epilog_slurmctld = <<>>,
                ext_sensors_type = <<>>,
                ext_sensors_freq = 0,
                federation_parameters = <<>>,
                first_job_id = 1,
                fs_dampening_factor = 1,
                gpu_freq_def = <<>>,
                hash_val = 0,
                health_check_interval = 0,
                health_check_node_state = 0,
                health_check_program = <<>>,
                inactive_limit = 0,
                job_acct_gather_freq = 30,
                job_acct_gather_type = <<"jobacct_gather/linux">>,
                job_acct_gather_params = <<>>,
                job_comp_host = <<>>,
                job_comp_loc = <<>>,
                job_comp_pass = <<>>,
                job_comp_port = 0,
                job_comp_type = <<"job_comp/none">>,
                job_comp_user = <<>>,
                job_container_type = <<>>,
                job_credential_private_key = <<>>,
                job_credential_public_certificate = <<>>,
                job_defaults_list = <<>>,
                job_file_append = 0,
                job_requeue = 1,
                job_submit_plugins = <<>>,
                keep_alive_time = 0,
                kill_on_bad_exit = 0,
                kill_wait = 30,
                launch_params = <<>>,
                launch_type = <<"launch/slurm">>,
                licenses = <<>>,
                log_fmt = 0,
                mail_domain = <<>>,
                mail_prog = <<"/bin/mail">>,
                max_array_size = 1001,
                max_batch_requeue = 5,
                max_dbd_msgs = 10000,
                max_job_count = 10000,
                max_job_id = 67108863,
                max_mem_per_cpu = 0,
                max_node_count = 0,
                max_step_count = 40000,
                max_tasks_per_node = 512,
                mcs_plugin = <<>>,
                mcs_plugin_params = <<>>,
                mem_limit_enforce = 1,
                min_job_age = 300,
                mpi_default = <<"none">>,
                mpi_params = <<>>,
                msg_aggr_params = <<>>,
                msg_timeout = 10,
                next_job_id = 100,
                node_features_plugins = <<>>,
                over_time_limit = 0,
                plugindir = <<"/usr/lib64/slurm">>,
                plug_stack_config = <<>>,
                power_parameters = <<>>,
                power_plugin = <<>>,
                preempt_mode = 0,
                preempt_type = <<"preempt/none">>,
                preempt_exempt_time = 0,
                prep_params = <<>>,
                prep_plugins = <<>>,
                priority_decay_half_life = 0,
                priority_calc_period = 300,
                priority_favor_small = 0,
                priority_flags = 0,
                priority_max_age = 0,
                priority_params = <<>>,
                priority_reset_period = 0,
                priority_type = <<"priority/basic">>,
                priority_weight_age = 0,
                priority_weight_assoc = 0,
                priority_weight_fair_share = 0,
                priority_weight_job_size = 0,
                priority_weight_partition = 0,
                priority_weight_qos = 0,
                priority_weight_tres = <<>>,
                private_data = 0,
                proctrack_type = <<"proctrack/cgroup">>,
                prolog = <<>>,
                prolog_epilog_timeout = 0,
                prolog_flags = 0,
                prolog_slurmctld = <<>>,
                propagate_prio_process = 0,
                propagate_rlimits = <<"ALL">>,
                propagate_rlimits_except = <<>>,
                reboot_program = <<>>,
                reconfig_flags = 0,
                requeue_exit = <<>>,
                requeue_exit_hold = <<>>,
                resume_fail_program = <<>>,
                resume_program = <<>>,
                resume_rate = 0,
                resume_timeout = 60,
                resv_epilog = <<>>,
                resv_over_run = 0,
                resv_prolog = <<>>,
                ret2service = 0,
                route_plugin = <<>>,
                sbcast_parameters = <<>>,
                sched_logfile = <<>>,
                sched_log_level = 0,
                sched_params = <<>>,
                sched_time_slice = 30,
                sched_type = <<"sched/backfill">>,
                scron_params = <<>>,
                select_type = <<"select/cons_tres">>,
                select_type_param = 0,
                site_factor_plugin = <<>>,
                site_factor_params = <<>>,
                slurm_conf = <<"/etc/slurm/slurm.conf">>,
                slurmd_debug = 3,
                slurmd_logfile = <<>>,
                slurmd_params = <<>>,
                slurmd_pidfile = <<"/var/run/slurmd.pid">>,
                slurmd_spooldir = <<"/var/spool/slurmd">>,
                slurmd_timeout = 300,
                slurmd_user_id = 0,
                slurmd_user_name = <<"root">>,
                slurmctld_addr = <<>>,
                slurmctld_debug = 3,
                slurmctld_logfile = <<>>,
                slurmctld_params = <<>>,
                slurmctld_pidfile = <<"/var/run/slurmctld.pid">>,
                slurmctld_plugstack = <<>>,
                slurmctld_plugstack_conf = <<>>,
                slurmctld_timeout = 120,
                slurm_version = <<"22.05.0">>,
                srun_epilog = <<>>,
                srun_port_range = <<>>,
                srun_prolog = <<>>,
                state_save_location = <<"/var/spool/slurmctld">>,
                suspend_exc_nodes = <<>>,
                suspend_exc_parts = <<>>,
                suspend_program = <<>>,
                suspend_rate = 0,
                suspend_time = 0,
                suspend_timeout = 60,
                switch_type = <<"switch/none">>,
                switch_params = <<>>,
                task_epilog = <<>>,
                task_plugin = <<"task/affinity">>,
                task_plugin_param = 0,
                task_prolog = <<>>,
                tcp_timeout = 2,
                tmp_fs = <<"/tmp">>,
                topology_param = <<>>,
                topology_plugin = <<"topology/none">>,
                track_wckey = 0,
                tree_width = 50,
                unkillable_step_program = <<>>,
                unkillable_step_timeout = 60,
                use_pam = 0,
                use_spec_resources = 0,
                version = <<"22.05.0">>,
                vsize_factor = 0,
                wait_time = 0,
                x11_parameters = <<>>
            },
            Body = flurm_protocol_codec:encode_build_info_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode config_info_response", fun() ->
            Resp = #config_info_response{
                last_update = 1234567890,
                config = <<"ClusterName=test\nSlurmctldHost=localhost\n">>
            },
            Body = flurm_protocol_codec:encode_config_info_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode stats_info_response", fun() ->
            Resp = #stats_info_response{
                parts_packed = 10,
                req_time = 1234567890,
                req_time_start = 1234560000,
                server_thread_count = 5,
                agent_queue_size = 0,
                agent_count = 3,
                agent_thread_count = 10,
                dbd_agent_queue_size = 0,
                gettimeofday_latency = 100,
                schedule_cycle_max = 1000,
                schedule_cycle_last = 500,
                schedule_cycle_sum = 10000,
                schedule_cycle_counter = 20,
                schedule_cycle_depth = 100,
                schedule_queue_len = 50,
                jobs_submitted = 1000,
                jobs_started = 950,
                jobs_completed = 900,
                jobs_canceled = 10,
                jobs_failed = 5,
                jobs_pending = 35,
                jobs_running = 50,
                job_states_ts = 1234567800,
                bf_backfilled_jobs = 100,
                bf_last_backfilled_jobs = 5,
                bf_cycle_counter = 100,
                bf_cycle_sum = 50000,
                bf_cycle_last = 500,
                bf_cycle_max = 2000,
                bf_last_depth = 100,
                bf_last_depth_try = 150,
                bf_depth_sum = 10000,
                bf_depth_try_sum = 15000,
                bf_queue_len = 50,
                bf_queue_len_sum = 5000,
                bf_when_last_cycle = 1234567700,
                bf_active = 1,
                rpc_type_stats = [],
                rpc_user_stats = []
            },
            Body = flurm_protocol_codec:encode_stats_info_response(Resp),
            ?assert(is_binary(Body))
        end}
    ].

%%%===================================================================
%%% Helper Function Tests - Comprehensive
%%%===================================================================

helper_function_comprehensive_tests() ->
    [
        {"ensure_binary with undefined", fun() ->
            ?assertEqual(<<>>, flurm_protocol_codec:ensure_binary(undefined))
        end},

        {"ensure_binary with null", fun() ->
            ?assertEqual(<<>>, flurm_protocol_codec:ensure_binary(null))
        end},

        {"ensure_binary with binary", fun() ->
            ?assertEqual(<<"test">>, flurm_protocol_codec:ensure_binary(<<"test">>))
        end},

        {"ensure_binary with list", fun() ->
            ?assertEqual(<<"hello">>, flurm_protocol_codec:ensure_binary("hello"))
        end},

        {"ensure_binary with other", fun() ->
            ?assertEqual(<<>>, flurm_protocol_codec:ensure_binary(123))
        end},

        {"ensure_integer with undefined", fun() ->
            ?assertEqual(0, flurm_protocol_codec:ensure_integer(undefined))
        end},

        {"ensure_integer with null", fun() ->
            ?assertEqual(0, flurm_protocol_codec:ensure_integer(null))
        end},

        {"ensure_integer with integer", fun() ->
            ?assertEqual(42, flurm_protocol_codec:ensure_integer(42))
        end},

        {"ensure_integer with other", fun() ->
            ?assertEqual(0, flurm_protocol_codec:ensure_integer(<<"not int">>))
        end},

        {"binary_to_hex converts correctly", fun() ->
            Result = flurm_protocol_codec:binary_to_hex(<<16#DE, 16#AD, 16#BE, 16#EF>>),
            ?assertEqual(<<"deadbeef">>, Result)
        end},

        {"binary_to_hex empty binary", fun() ->
            ?assertEqual(<<>>, flurm_protocol_codec:binary_to_hex(<<>>))
        end},

        {"binary_to_hex single byte", fun() ->
            ?assertEqual(<<"ff">>, flurm_protocol_codec:binary_to_hex(<<255>>))
        end},

        {"binary_to_hex leading zero", fun() ->
            ?assertEqual(<<"0f">>, flurm_protocol_codec:binary_to_hex(<<15>>))
        end}
    ].

%%%===================================================================
%%% Job Step Info Tests - Comprehensive
%%%===================================================================

job_step_info_comprehensive_tests() ->
    [
        {"encode job_step_info_response empty", fun() ->
            Resp = #job_step_info_response{
                last_update = 1234567890,
                steps = []
            },
            Body = flurm_protocol_codec:encode_job_step_info_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode job_step_info_response with step", fun() ->
            Step = #job_step_info{
                step_id = 0,
                job_id = 12345,
                user_id = 1000,
                num_tasks = 4,
                num_cpus = 4,
                cpu_freq_min = 0,
                cpu_freq_max = 0,
                cpu_freq_gov = 0,
                partition = <<"debug">>,
                name = <<"step0">>,
                node_list = <<"node01">>,
                start_time = 1234567890,
                run_time = 100,
                state = 1,
                tres_alloc_str = <<"cpu=4,mem=8G">>
            },
            Resp = #job_step_info_response{
                last_update = 1234567890,
                steps = [Step]
            },
            Body = flurm_protocol_codec:encode_job_step_info_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode job_step_create_response", fun() ->
            Resp = #job_step_create_response{
                step_id = 0,
                job_id = 12345,
                node_list = <<"node[01-04]">>,
                return_code = 0
            },
            Body = flurm_protocol_codec:encode_job_step_create_response(Resp),
            ?assert(is_binary(Body))
        end}
    ].

%%%===================================================================
%%% Launch Tasks Tests - Comprehensive
%%%===================================================================

launch_tasks_comprehensive_tests() ->
    [
        {"encode launch_tasks_response record", fun() ->
            Resp = #launch_tasks_response{
                return_code = 0,
                node_name = <<"node01">>,
                count_of_pids = 0,
                local_pids = []
            },
            Body = flurm_protocol_codec:encode_launch_tasks_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode launch_tasks_response map", fun() ->
            Map = #{
                return_code => 0,
                node_name => <<"node01">>,
                count_of_pids => 0,
                local_pids => []
            },
            Body = flurm_protocol_codec:encode_launch_tasks_response(Map),
            ?assert(is_binary(Body))
        end},

        {"encode launch_tasks_response with pids", fun() ->
            Resp = #launch_tasks_response{
                return_code = 0,
                node_name = <<"node01">>,
                count_of_pids = 2,
                local_pids = [1234, 5678]
            },
            Body = flurm_protocol_codec:encode_launch_tasks_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode task_exit_msg map", fun() ->
            Map = #{
                job_id => 12345,
                step_id => 0,
                exit_status => 0,
                num_tasks => 1,
                task_id_list => [0]
            },
            Body = flurm_protocol_codec:encode_task_exit_msg(Map),
            ?assert(is_binary(Body))
        end},

        {"encode reattach_tasks_response record", fun() ->
            Resp = #reattach_tasks_response{
                return_code = 0,
                node_name = <<"node01">>,
                gtids = [],
                local_pids = [],
                executable_names = []
            },
            Body = flurm_protocol_codec:encode_reattach_tasks_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode reattach_tasks_response map", fun() ->
            Map = #{
                return_code => 0,
                node_name => <<"node01">>,
                gtids => [0, 1],
                local_pids => [1234, 5678],
                executable_names => [<<"./a.out">>, <<"./a.out">>]
            },
            Body = flurm_protocol_codec:encode_reattach_tasks_response(Map),
            ?assert(is_binary(Body))
        end}
    ].

%%%===================================================================
%%% Reconfigure Tests - Comprehensive
%%%===================================================================

reconfigure_comprehensive_tests() ->
    [
        {"decode reconfigure_request empty", fun() ->
            Result = flurm_protocol_codec:decode_body(?REQUEST_RECONFIGURE, <<>>),
            ?assertMatch({ok, #reconfigure_request{}}, Result)
        end},

        {"decode reconfigure_request with flags", fun() ->
            Binary = <<16#FF:32/big, 0, 0, 0, 0>>,
            Result = flurm_protocol_codec:decode_body(?REQUEST_RECONFIGURE, Binary),
            ?assertMatch({ok, #reconfigure_request{flags = 16#FF}}, Result)
        end},

        {"decode reconfigure_with_config_request empty", fun() ->
            Result = flurm_protocol_codec:decode_body(?REQUEST_RECONFIGURE_WITH_CONFIG, <<>>),
            ?assertMatch({ok, #reconfigure_with_config_request{}}, Result)
        end},

        {"decode reconfigure_with_config_request with data", fun() ->
            %% Config data with count and settings
            Binary = <<1:32/big,               % count = 1
                       4:32/big, "test",       % key
                       5:32/big, "value">>,    % value
            Result = flurm_protocol_codec:decode_body(?REQUEST_RECONFIGURE_WITH_CONFIG, Binary),
            ?assertMatch({ok, #reconfigure_with_config_request{}}, Result)
        end},

        {"encode reconfigure_response success", fun() ->
            Resp = #reconfigure_response{return_code = 0},
            Body = flurm_protocol_codec:encode_reconfigure_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode reconfigure_response failure", fun() ->
            Resp = #reconfigure_response{return_code = -1},
            Body = flurm_protocol_codec:encode_reconfigure_response(Resp),
            ?assert(is_binary(Body))
        end}
    ].

%%%===================================================================
%%% Shutdown Tests
%%%===================================================================

shutdown_tests() ->
    [
        {"decode shutdown_request", fun() ->
            Binary = <<0:16/big, 0:16/big>>,
            Result = flurm_protocol_codec:decode_body(?REQUEST_SHUTDOWN, Binary),
            ?assertMatch({ok, #shutdown_request{}}, Result)
        end},

        {"decode stats_info_request", fun() ->
            Binary = <<0:32/big, 0:32/big>>,
            Result = flurm_protocol_codec:decode_body(?REQUEST_STATS_INFO, Binary),
            ?assertMatch({ok, #stats_info_request{}}, Result)
        end}
    ].

%%%===================================================================
%%% Binary Packing Tests
%%%===================================================================

binary_packing_tests() ->
    [
        {"pack_slurm_addr IPv4 tuple", fun() ->
            Addr = {192, 168, 1, 100},
            Port = 6818,
            Result = flurm_protocol_codec:pack_slurm_addr(Addr, Port),
            ?assert(is_binary(Result)),
            ?assertEqual(6, byte_size(Result))
        end},

        {"pack_slurm_addr binary IP", fun() ->
            Addr = <<192, 168, 1, 100>>,
            Port = 6818,
            Result = flurm_protocol_codec:pack_slurm_addr(Addr, Port),
            ?assert(is_binary(Result))
        end},

        {"encode_cpu_groups zero groups", fun() ->
            Result = flurm_protocol_codec:encode_cpu_groups(0, [], []),
            ?assertEqual(<<0:32/big>>, Result)
        end},

        {"encode_cpu_groups one group", fun() ->
            Result = flurm_protocol_codec:encode_cpu_groups(1, [4], [1]),
            ?assert(is_binary(Result))
        end},

        {"encode_node_inx empty", fun() ->
            Result = flurm_protocol_codec:encode_node_inx([]),
            ?assert(is_binary(Result))
        end},

        {"encode_node_inx with indices", fun() ->
            Result = flurm_protocol_codec:encode_node_inx([0, 1, 2, 3]),
            ?assert(is_binary(Result))
        end},

        {"encode_string_list empty", fun() ->
            Result = flurm_protocol_codec:encode_string_list([]),
            ?assertEqual(<<0:32/big>>, Result)
        end},

        {"encode_string_list with strings", fun() ->
            Result = flurm_protocol_codec:encode_string_list([<<"hello">>, <<"world">>]),
            ?assert(is_binary(Result)),
            <<Count:32/big, _Rest/binary>> = Result,
            ?assertEqual(2, Count)
        end}
    ].

%%%===================================================================
%%% Node and Partition Info Extended Tests
%%%===================================================================

node_partition_extended_tests() ->
    [
        {"encode node_info_response with multiple nodes", fun() ->
            Node1 = #node_info{
                name = <<"node01">>,
                hostname = <<"node01.cluster">>,
                state = 1,
                cpus = 32,
                boards = 1,
                sockets = 2,
                cores = 8,
                threads = 2,
                real_memory = 131072,
                tmp_disk = 102400,
                boot_time = 1234560000,
                slurmd_start_time = 1234560100,
                arch = <<"x86_64">>,
                os = <<"Linux">>,
                features = <<"avx2,sse4">>,
                features_act = <<"avx2,sse4">>,
                gres = <<"gpu:4">>,
                gres_drain = <<>>,
                gres_used = <<"gpu:2">>,
                version = <<"22.05.0">>
            },
            Node2 = #node_info{
                name = <<"node02">>,
                hostname = <<"node02.cluster">>,
                state = 1,
                cpus = 64,
                boards = 1,
                sockets = 4,
                cores = 8,
                threads = 2,
                real_memory = 262144,
                tmp_disk = 204800,
                boot_time = 1234560000,
                slurmd_start_time = 1234560100,
                arch = <<"x86_64">>,
                os = <<"Linux">>,
                features = <<"avx512,sse4">>,
                features_act = <<"avx512,sse4">>,
                gres = <<"gpu:8">>,
                gres_drain = <<>>,
                gres_used = <<"gpu:4">>,
                version = <<"22.05.0">>
            },
            Resp = #node_info_response{
                last_update = 1234567890,
                nodes = [Node1, Node2]
            },
            Body = flurm_protocol_codec:encode_node_info_response(Resp),
            ?assert(is_binary(Body)),
            ?assert(byte_size(Body) > 100)
        end},

        {"encode partition_info_response with multiple partitions", fun() ->
            Part1 = #partition_info{
                name = <<"debug">>,
                nodes = <<"node[01-02]">>,
                total_nodes = 2,
                total_cpus = 96,
                max_time = 3600,
                default_time = 1800,
                max_nodes = 2,
                min_nodes = 1,
                state_up = 1,
                flags = 0,
                allow_groups = <<"users">>,
                allow_accounts = <<"*">>,
                deny_accounts = <<>>,
                allow_qos = <<"*">>,
                deny_qos = <<>>,
                qos_char = <<"normal">>,
                alternate = <<>>,
                def_mem_per_cpu = 4096,
                max_mem_per_cpu = 8192,
                priority_job_factor = 1,
                priority_tier = 1,
                preempt_mode = 0
            },
            Part2 = #partition_info{
                name = <<"batch">>,
                nodes = <<"node[03-10]">>,
                total_nodes = 8,
                total_cpus = 256,
                max_time = 86400,
                default_time = 3600,
                max_nodes = 8,
                min_nodes = 1,
                state_up = 1,
                flags = 1,
                allow_groups = <<"*">>,
                allow_accounts = <<"*">>,
                deny_accounts = <<>>,
                allow_qos = <<"*">>,
                deny_qos = <<>>,
                qos_char = <<"normal">>,
                alternate = <<>>,
                def_mem_per_cpu = 4096,
                max_mem_per_cpu = 16384,
                priority_job_factor = 2,
                priority_tier = 2,
                preempt_mode = 0
            },
            Resp = #partition_info_response{
                last_update = 1234567890,
                partitions = [Part1, Part2]
            },
            Body = flurm_protocol_codec:encode_partition_info_response(Resp),
            ?assert(is_binary(Body)),
            ?assert(byte_size(Body) > 100)
        end}
    ].

%%%===================================================================
%%% Job Info Extended Tests
%%%===================================================================

job_info_extended_tests() ->
    [
        {"encode job_info_response with complex job", fun() ->
            Job = #job_info{
                job_id = 12345,
                array_job_id = 0,
                array_task_id = 0,
                user_id = 1000,
                group_id = 1000,
                profile = 0,
                name = <<"my_complex_job">>,
                user_name = <<"testuser">>,
                partition = <<"batch">>,
                account = <<"research">>,
                qos = <<"normal">>,
                state = 1,  % RUNNING
                state_reason = 0,
                priority = 1000,
                nice = 0,
                time_limit = 86400,
                time_min = 0,
                submit_time = 1234560000,
                start_time = 1234567890,
                end_time = 0,
                suspend_time = 0,
                pre_sus_time = 0,
                deadline = 0,
                resize_time = 0,
                preempt_time = 0,
                eligible_time = 1234560000,
                accrue_time = 1234560000,
                last_sched_eval = 1234567800,
                exit_code = 0,
                derived_exit_code = 0,
                num_nodes = 4,
                num_cpus = 128,
                cpus_per_task = 1,
                ntasks_per_node = 32,
                ntasks_per_socket = 0,
                ntasks_per_core = 0,
                ntasks_per_board = 0,
                pn_min_cpus = 1,
                pn_min_memory = 4096,
                pn_min_tmp_disk = 0,
                core_spec = 0,
                thread_spec = 0,
                batch_flag = 1,
                batch_host = <<"node01">>,
                command = <<"/home/user/job.sh">>,
                dependency = <<>>,
                nodes = <<"node[01-04]">>,
                features = <<"avx2">>,
                cluster_features = <<>>,
                prefer = <<>>,
                work_dir = <<"/home/user/work">>,
                std_in = <<"/dev/null">>,
                std_out = <<"/home/user/job.out">>,
                std_err = <<"/home/user/job.err">>,
                comment = <<"Test job">>,
                admin_comment = <<>>,
                system_comment = <<>>,
                burst_buffer = <<>>,
                burst_buffer_state = <<>>,
                wckey = <<>>,
                network = <<>>,
                sockets_per_node = 0,
                cores_per_socket = 0,
                threads_per_core = 0,
                licenses = <<>>,
                gres_used = <<"gpu:4">>,
                resv_name = <<>>,
                tres_req_str = <<"cpu=128,mem=16G,node=4">>,
                tres_alloc_str = <<"cpu=128,mem=16G,node=4">>,
                exc_nodes = <<>>,
                req_nodes = <<>>,
                mcs_label = <<>>,
                shared = 0,
                contiguous = 0,
                reboot = 0,
                requeue = 1,
                restart_cnt = 0,
                delay_boot = 0,
                mail_user = <<"user@example.com">>,
                mail_type = 3,  % BEGIN | END
                power_flags = 0,
                het_job_id = 0,
                het_job_id_set = <<>>,
                het_job_offset = 0
            },
            Resp = #job_info_response{
                last_update = 1234567890,
                jobs = [Job]
            },
            Body = flurm_protocol_codec:encode_job_info_response(Resp),
            ?assert(is_binary(Body)),
            ?assert(byte_size(Body) > 200)
        end},

        {"encode job_info_response multiple jobs", fun() ->
            Jobs = [#job_info{
                job_id = N,
                user_id = 1000 + N,
                group_id = 1000,
                name = list_to_binary("job" ++ integer_to_list(N)),
                user_name = <<"user">>,
                partition = <<"batch">>,
                state = 1,
                num_cpus = N * 4,
                num_nodes = N
            } || N <- lists:seq(1, 10)],
            Resp = #job_info_response{
                last_update = 1234567890,
                jobs = Jobs
            },
            Body = flurm_protocol_codec:encode_job_info_response(Resp),
            ?assert(is_binary(Body))
        end}
    ].

%%%===================================================================
%%% Resource Allocation Extended Tests
%%%===================================================================

resource_allocation_extended_tests() ->
    [
        {"encode resource_allocation_response complex", fun() ->
            Resp = #resource_allocation_response{
                job_id = 12345,
                node_list = <<"node[01-04]">>,
                partition = <<"batch">>,
                num_cpu_groups = 1,
                cpus_per_node = [32],
                cpu_count_reps = [4],
                alias_list = <<"node01,node02,node03,node04">>,
                error_code = 0,
                select_jobinfo = <<>>,
                node_cnt = 4
            },
            Body = flurm_protocol_codec:encode_resource_allocation_response(Resp),
            ?assert(is_binary(Body)),
            ?assert(byte_size(Body) > 20)
        end},

        {"encode job_allocation_info_response", fun() ->
            Resp = #job_allocation_info_response{
                job_id = 12345,
                node_list = <<"node[01-08]">>,
                partition = <<"large">>,
                num_cpu_groups = 2,
                cpus_per_node = [32, 64],
                cpu_count_reps = [4, 4],
                error_code = 0,
                node_cnt = 8
            },
            Body = flurm_protocol_codec:encode_body(?RESPONSE_JOB_ALLOCATION_INFO, Resp),
            ?assert(is_binary(Body))
        end}
    ].

%%%===================================================================
%%% SRUN Callback Message Tests - Extended
%%%===================================================================

srun_callback_extended_tests() ->
    [
        {"encode srun_job_complete with step", fun() ->
            Msg = #srun_job_complete{
                job_id = 12345,
                step_id = 5
            },
            Body = flurm_protocol_codec:encode_srun_job_complete(Msg),
            ?assert(is_binary(Body)),
            <<JobId:32/big, StepId:32/big>> = Body,
            ?assertEqual(12345, JobId),
            ?assertEqual(5, StepId)
        end},

        {"encode srun_ping", fun() ->
            Msg = #srun_ping{},
            Body = flurm_protocol_codec:encode_srun_ping(Msg),
            ?assert(is_binary(Body))
        end},

        {"encode job_will_run_response", fun() ->
            Resp = #job_will_run_response{
                job_id = 12345,
                node_list = <<"node[01-04]">>,
                start_time = 1234567890,
                return_code = 0
            },
            Body = flurm_protocol_codec:encode_job_will_run_response(Resp),
            ?assert(is_binary(Body))
        end}
    ].

%%%===================================================================
%%% Decode Request Tests - Extended
%%%===================================================================

decode_request_extended_tests() ->
    [
        {"decode job_will_run_request", fun() ->
            %% Minimal job_will_run_request binary
            Binary = <<0:32/big, 0:32/big, 0:32/big, 0:32/big,
                       0:32/big, 0:32/big, 0:32/big, 0:32/big,
                       0:32/big, 0:32/big, 0:32/big, 0:32/big,
                       0:32/big, 0:32/big, 0:32/big, 0:32/big,
                       0:32/big, 0:32/big, 0:32/big, 0:32/big>>,
            Result = flurm_protocol_codec:decode_body(?REQUEST_JOB_WILL_RUN, Binary),
            ?assertMatch({ok, _}, Result)
        end},

        {"decode update_job_request", fun() ->
            Binary = <<12345:32/big, 0:32/big, 0:32/big, 0:32/big,
                       0:32/big, 0:32/big, 0:32/big, 0:32/big,
                       0:32/big, 0:32/big, 0:32/big, 0:32/big,
                       0:32/big, 0:32/big, 0:32/big, 0:32/big,
                       0:32/big, 0:32/big, 0:32/big, 0:32/big>>,
            Result = flurm_protocol_codec:decode_body(?REQUEST_UPDATE_JOB, Binary),
            ?assertMatch({ok, _}, Result)
        end},

        {"decode reservation_info_request", fun() ->
            Binary = <<0:32/big, 0:32/big>>,
            Result = flurm_protocol_codec:decode_body(?REQUEST_RESERVATION_INFO, Binary),
            ?assertMatch({ok, #reservation_info_request{}}, Result)
        end},

        {"decode license_info_request", fun() ->
            Binary = <<0:32/big, 0:32/big>>,
            Result = flurm_protocol_codec:decode_body(?REQUEST_LICENSE_INFO, Binary),
            ?assertMatch({ok, #license_info_request{}}, Result)
        end},

        {"decode topo_info_request", fun() ->
            Binary = <<0:32/big, 0:32/big>>,
            Result = flurm_protocol_codec:decode_body(?REQUEST_TOPO_INFO, Binary),
            ?assertMatch({ok, #topo_info_request{}}, Result)
        end},

        {"decode front_end_info_request", fun() ->
            Binary = <<0:32/big, 0:32/big>>,
            Result = flurm_protocol_codec:decode_body(?REQUEST_FRONT_END_INFO, Binary),
            ?assertMatch({ok, #front_end_info_request{}}, Result)
        end},

        {"decode burst_buffer_info_request", fun() ->
            Binary = <<0:32/big, 0:32/big>>,
            Result = flurm_protocol_codec:decode_body(?REQUEST_BURST_BUFFER_INFO, Binary),
            ?assertMatch({ok, #burst_buffer_info_request{}}, Result)
        end},

        {"decode build_info_request", fun() ->
            Result = flurm_protocol_codec:decode_body(?REQUEST_BUILD_INFO, <<>>),
            ?assertMatch({ok, #build_info_request{}}, Result)
        end},

        {"decode config_info_request", fun() ->
            Result = flurm_protocol_codec:decode_body(?REQUEST_CONFIG_INFO, <<>>),
            ?assertMatch({ok, #config_info_request{}}, Result)
        end}
    ].

%%%===================================================================
%%% String Unpacking Tests
%%%===================================================================

string_unpacking_tests() ->
    [
        {"unpack_string_safe with valid string", fun() ->
            Str = <<"hello">>,
            Binary = <<5:32/big, Str/binary, "extra">>,
            {ok, Result, Rest} = flurm_protocol_codec:unpack_string_safe(Binary),
            ?assertEqual(<<"hello">>, Result),
            ?assertEqual(<<"extra">>, Rest)
        end},

        {"unpack_string_safe with null marker", fun() ->
            Binary = <<16#FFFFFFFF:32, "rest">>,
            {ok, Result, Rest} = flurm_protocol_codec:unpack_string_safe(Binary),
            ?assertEqual(<<>>, Result),
            ?assertEqual(<<"rest">>, Rest)
        end},

        {"unpack_string_safe with truncated", fun() ->
            Binary = <<100:32/big, "short">>,
            Result = flurm_protocol_codec:unpack_string_safe(Binary),
            ?assertMatch({error, _}, Result)
        end},

        {"unpack_string_safe with very short", fun() ->
            Binary = <<1, 2>>,
            Result = flurm_protocol_codec:unpack_string_safe(Binary),
            ?assertMatch({error, _}, Result)
        end}
    ].

%%%===================================================================
%%% Message Type Classification Tests - Extended
%%%===================================================================

message_type_classification_extended_tests() ->
    [
        {"is_response for node info", fun() ->
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_NODE_INFO))
        end},

        {"is_response for partition info", fun() ->
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_PARTITION_INFO))
        end},

        {"is_response for submit batch job", fun() ->
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_SUBMIT_BATCH_JOB))
        end},

        {"is_response for job step create", fun() ->
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_JOB_STEP_CREATE))
        end},

        {"is_response for job step info", fun() ->
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_JOB_STEP_INFO))
        end},

        {"is_response for resource allocation", fun() ->
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_RESOURCE_ALLOCATION))
        end},

        {"is_response for job allocation info", fun() ->
            ?assert(flurm_protocol_codec:is_response(?RESPONSE_JOB_ALLOCATION_INFO))
        end},

        {"not is_response for request", fun() ->
            ?assertNot(flurm_protocol_codec:is_response(?REQUEST_PING))
        end},

        {"not is_response for submit batch job request", fun() ->
            ?assertNot(flurm_protocol_codec:is_response(?REQUEST_SUBMIT_BATCH_JOB))
        end},

        {"message_type_name for node info request", fun() ->
            ?assertEqual(request_node_info, flurm_protocol_codec:message_type_name(?REQUEST_NODE_INFO))
        end},

        {"message_type_name for partition info request", fun() ->
            ?assertEqual(request_partition_info, flurm_protocol_codec:message_type_name(?REQUEST_PARTITION_INFO))
        end},

        {"message_type_name for cancel job", fun() ->
            ?assertEqual(request_cancel_job, flurm_protocol_codec:message_type_name(?REQUEST_CANCEL_JOB))
        end}
    ].

%%%===================================================================
%%% Decode Body Extended Tests - More Message Types
%%%===================================================================

decode_body_extended_tests() ->
    [
        {"decode body unknown type returns passthrough", fun() ->
            Binary = <<1, 2, 3, 4, 5>>,
            Result = flurm_protocol_codec:decode_body(99999, Binary),
            ?assertMatch({ok, Binary}, Result)
        end},

        {"decode complete_prolog request", fun() ->
            JobId = 12345,
            Binary = <<JobId:32/big, 0:32/big, 0:32/big, 0:32/big>>,
            Result = flurm_protocol_codec:decode_body(?REQUEST_COMPLETE_PROLOG, Binary),
            ?assertMatch({ok, #complete_prolog_request{}}, Result)
        end},

        {"decode epilog_complete message", fun() ->
            JobId = 12345,
            Binary = <<JobId:32/big, 0:32/big, 0:32/big, 0:32/big, 0:32/big>>,
            Result = flurm_protocol_codec:decode_body(?MESSAGE_EPILOG_COMPLETE, Binary),
            ?assertMatch({ok, #epilog_complete_msg{}}, Result)
        end},

        {"decode task_exit message", fun() ->
            JobId = 12345,
            Binary = <<JobId:32/big, 0:32/big, 0:32/big, 0:32/big, 0:32/big>>,
            Result = flurm_protocol_codec:decode_body(?MESSAGE_TASK_EXIT, Binary),
            ?assertMatch({ok, #task_exit_msg{}}, Result)
        end}
    ].

%%%===================================================================
%%% Encode Body Extended Tests - More Message Types
%%%===================================================================

encode_body_extended_tests() ->
    [
        {"encode body for job ready response", fun() ->
            Resp = #job_ready_response{
                job_id = 12345,
                return_code = 0
            },
            Body = flurm_protocol_codec:encode_body(?RESPONSE_JOB_READY, Resp),
            ?assert(is_binary(Body))
        end},

        {"encode body for srun_job_complete", fun() ->
            Msg = #srun_job_complete{
                job_id = 12345,
                step_id = 0
            },
            Body = flurm_protocol_codec:encode_body(?SRUN_JOB_COMPLETE, Msg),
            ?assert(is_binary(Body))
        end},

        {"encode body for srun_ping", fun() ->
            Msg = #srun_ping{},
            Body = flurm_protocol_codec:encode_body(?SRUN_PING, Msg),
            ?assert(is_binary(Body))
        end}
    ].

%%%===================================================================
%%% Batch Job Response Encoding Tests
%%%===================================================================

batch_job_response_encoding_tests() ->
    [
        {"encode batch_job_response full", fun() ->
            Resp = #batch_job_response{
                job_id = 12345,
                step_id = 0,
                error_code = 0
            },
            Body = flurm_protocol_codec:encode_batch_job_response(Resp),
            ?assert(is_binary(Body))
        end},

        {"encode batch_job_response with error", fun() ->
            Resp = #batch_job_response{
                job_id = 0,
                step_id = 0,
                error_code = -1
            },
            Body = flurm_protocol_codec:encode_batch_job_response(Resp),
            ?assert(is_binary(Body))
        end}
    ].

%%%===================================================================
%%% Extended Roundtrip Tests
%%%===================================================================

extended_roundtrip_tests() ->
    [
        {"roundtrip job_info_request", fun() ->
            Req = #job_info_request{
                show_flags = 16#01,
                user_id = 1000,
                job_id = 0
            },
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_JOB_INFO, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(?REQUEST_JOB_INFO, Msg#slurm_msg.header#slurm_header.msg_type)
        end},

        {"roundtrip node_info_request", fun() ->
            Req = #node_info_request{
                show_flags = 0
            },
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_NODE_INFO, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(?REQUEST_NODE_INFO, Msg#slurm_msg.header#slurm_header.msg_type)
        end},

        {"roundtrip partition_info_request", fun() ->
            Req = #partition_info_request{
                show_flags = 0
            },
            {ok, Encoded} = flurm_protocol_codec:encode(?REQUEST_PARTITION_INFO, Req),
            {ok, Msg, <<>>} = flurm_protocol_codec:decode(Encoded),
            ?assertEqual(?REQUEST_PARTITION_INFO, Msg#slurm_msg.header#slurm_header.msg_type)
        end}
    ].

%%%===================================================================
%%% Settings Map Tests
%%%===================================================================

settings_map_tests() ->
    [
        {"encode_settings_map empty", fun() ->
            Result = flurm_protocol_codec:encode_settings_map([]),
            ?assertEqual(<<0:32/big>>, Result)
        end},

        {"encode_settings_map with entries", fun() ->
            Settings = [{<<"key1">>, <<"value1">>}, {<<"key2">>, <<"value2">>}],
            Result = flurm_protocol_codec:encode_settings_map(Settings),
            ?assert(is_binary(Result)),
            <<Count:32/big, _/binary>> = Result,
            ?assertEqual(2, Count)
        end}
    ].

%%%===================================================================
%%% Fed Clusters Tests
%%%===================================================================

fed_clusters_tests() ->
    [
        {"encode_fed_clusters empty", fun() ->
            Result = flurm_protocol_codec:encode_fed_clusters([]),
            ?assertEqual(<<0:32/big>>, Result)
        end},

        {"encode_fed_clusters with clusters", fun() ->
            Clusters = [
                #{name => <<"cluster1">>, host => <<"host1">>, port => 6817},
                #{name => <<"cluster2">>, host => <<"host2">>, port => 6817}
            ],
            Result = flurm_protocol_codec:encode_fed_clusters(Clusters),
            ?assert(is_binary(Result)),
            <<Count:32/big, _/binary>> = Result,
            ?assertEqual(2, Count)
        end}
    ].
